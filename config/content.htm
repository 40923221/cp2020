<h1>About</h1>
<p style="text-align: left;"><br/>4092321的作業</p>
<p style="text-align: left;"><img alt="" height="480" src="/images/螢幕擷取畫面 2020-10-18 214456.png" width="978"/></p>
<h1>上課筆記</h1>
<p><img alt="" height="419" src="/images/8f5326ad68ff50f29008a165538a460b.jpg" width="553"/></p>
<h2>第一周-cp2020 introduction to computer programming</h2>
<p>單字:repositroy=倉儲 DNS=域名解析 proxy=代理主機 remote=遠端 distributed=分散</p>
<p>主機最下方為瑞昱(Realtek)網路接口</p>
<p>在2012年全台校園皆改為IPv6(<span>Internet Protocol version 6)<b>網際協定第6版</b></span></p>
<p><span>2001:6004:168::1為中華電信的DNS(用"::"表示一組0或多組0，但是只能出現一次)</span></p>
<p style="text-align: center;"><span>________</span><span>________</span><span>________</span><span>________</span>網路測試<span>________</span><span>________________________</span></p>
<p style="text-align: left;"><span>(1)screah "CMD" type in "ipconfig /all" (ipconfig = Internet protocol configuration)</span></p>
<p style="text-align: left;"><span>(2)type in "ping 2001:288:6004:17:254" (傳送一次封包)(ps. a.kmol.info是短名稱)</span></p>
<p style="text-align: left;">    <span>type in "ping -t 2001:288:6004:17:254" (傳送多次封包)</span></p>
<p style="text-align: left;">IPv6轉譯位址有69、53、42(由大至小)port為3128(在校內)</p>
<p style="text-align: center;"><span>______</span><span>_______</span><span>_______</span><span>________</span>IPv6 setting in chrome<span>_______</span><span>________</span><span>________</span><span>_____</span></p>
<p style="text-align: left;">step:打開google chrome<span>→圖示<img alt="" height="16" src="/images/螢幕擷取畫面 2020-10-21 173822.png" width="11"/>→選擇setting→開啟Advance→在system有Open your computer's proxy setting並將其開啟</span></p>
<h2 style="text-align: left;"><span>W2</span></h2>
<p><span>下載 fall2020 cp.7z 或是 fall2020 V2.7.7z</span></p>
<p><span>CMD指令:</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">Ctrl + z 退出python
dir 看目錄
cd.. 回上一頁
cd \ 回根目錄
C: 去C槽</pre>
<p>登入Github，點擊右上方+，選擇New repository輸入名稱，選擇public、add a READEM file、Add gitignore並選擇python即可完成</p>
<h1>PCH 11 Networking Media</h1>
<p><a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed60a0001dc34b7c631f7c68297"><span>傳送門:</span></a><a href="https://oli.cmu.edu/jcourse/webui/syllabus/module.do?context=d87f2ed50a0001dc1a3f7bbafbe683af">https://oli.cmu.edu/jcourse/webui/syllabus/module.do?context=d87f2ed50a0001dc1a3f7bbafbe683af</a></p>
<h2>Fiber-Optic Cable光纖電纜</h2>
<div class="tw-ta-container hide-focus-ring tw-nfl" id="tw-target-rmn-container"></div>
<p><a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed60a0001dc34b7c631f7c68297"><span>傳送門:</span></a><a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed60a0001dc34b7c631f7c68297">https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed60a0001dc34b7c631f7c68297</a></p>
<h3>Overview總覽</h3>
<p><a href="https://github.com/mdecourse/cmsimde"></a><span>In this module</span><span>, we’re going to discuss the various types of network media.</span></p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW">在這個模組中，</span><span lang="zh-TW">我們將討論各種類型的網絡媒體。</span></pre>
<p><span> We will begin with fiber-optic cable and then discuss twisted pair cable and coaxial cable.</span></p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">我們將從光纖電纜開始，然後討論雙絞線電纜和同軸電纜。</span></pre>
<p><span> For each of these cable types, we will discuss appearance, characteristics, and types of connectors, as well as speed and limitations.</span></p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW">對於每種電纜類型，我們將討論連接器的外觀，特性和類型，以及速度和限制。<br/></span></pre>
<h3>Fiber-Optic Cable光纖電纜</h3>
<p id="N10692" lang="">Fiber-optic cables are constructed by using a glass core at the center of the cable that is surrounded by cladding.</p>
<p lang=""><span>光纖電纜是通過在電纜的中心使用玻璃芯構成的，該玻璃芯被包層圍繞。</span></p>
<p lang="">In order to send data from one end of the cable to the other, light from a light-emitting diode (LED) or laser is used to transmit the signal down the glass fiber at the center of the cable.</p>
<p lang=""><span>為了將數據從電纜的一端發送到另一端，可使用來自發光二極管（LED）或激光的光沿電纜中心的玻璃纖維向下傳輸信號。</span></p>
<p lang="">Because the data is being transmitted using light, it is immune to the effects of electromagnetic interference (EMI) that impact traditional copper-based cables, such as twisted pair and coaxial cables.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">由於數據是通過光傳輸的，因此不受電磁干擾（EMI）的影響，電磁干擾會影響傳統的銅基電纜，如雙絞線和同軸電纜。</span></pre>
<p lang="">Fiber-optic cables possess the ability to send the data a very far distance (many miles) without the use of a repeater.</p>
<p lang="">光纖具有無需使用中繼器就可以很遠的距離（許多英里）發送數據的能力。</p>
<p lang="">They also can carry a significant amount of data due to their large bandwidth and the information traveling at light speed.</p>
<p lang="">由於它們的大帶寬和以光速傳播的信息，它們還可以攜帶大量數據。</p>
<p lang="">Their bandwidth can be measured in gigabits or even terabits per second.</p>
<p lang="">它們的帶寬可以每秒千兆比特或什至兆兆比特來度量。</p>
<p lang="">There are two types of fiber cables: multimode and single-mode fiber.</p>
<div class="tw-ta-container hide-focus-ring tw-lfl" id="tw-target-text-container" tabindex="0">
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">光纖電纜有兩種類型：多模和單模光纖。<br/><img alt="" height="411" src="/images/image1.png" width="383"/><br/></span></pre>
</div>
<div class="tw-ta-container hide-focus-ring tw-nfl" id="tw-target-rmn-container">
<p id="N106A2" lang="">Multimode fiber cables (MMF) contain a larger core than the single-mode variety.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">多模光纜（MMF）的芯線比單模光纜大。</span></pre>
<p lang="">The core size for a multimode fiber is 62.5 microns.</p>
<p lang="">多模光纖的纖芯尺寸為62.5微米。</p>
<p lang="">A micron is a very small unit of measurement—it is actually even smaller than the width of a human hair.</p>
<p lang="">微米是非常小的度量單位，實際上甚至比人類頭髮的寬度還小。</p>
<p lang="">MMF’s larger core enables multiple modes of travel for the light from one end of the cable to the other.</p>
<p lang="">MMF的較大芯線實現了從電纜一端到另一端的多種傳播模式。</p>
<p lang="">This allows a single fiber to carry multiple signals across it, with each signal being transmitted at a slightly different reflective angle.</p>
<p lang="">這樣一來，單根光纖就可以在其上傳輸多個信號，而每個信號都以稍微不同的反射角傳輸。</p>
<p lang="">When the light reaches the destination, the signals are then converted back into 1s and 0s and passed to the computer by the network interface card.</p>
<p lang="">當光到達目的地時，信號然後被轉換回1和0，然後通過網絡接口卡傳遞到計算機。</p>
<p lang="">Multimode fiber is commonly used in shorter distance fiber connections, such as from a router to a switch, a switch to a switch, or a server to a switch.</p>
<p lang="">多模光纖通常用於較短距離的光纖連接中，例如從路由器到交換機，從交換機到交換機或從服務器到交換機。</p>
<p id="N106A5" lang="">Single-mode fiber cables (SMF) contain a much smaller core than the multimode variety.</p>
<p lang="">單模光纜（SMF）的芯線比多模光纜小得多。</p>
<p lang="">The core size for SMF is 10 microns. SMF’s smaller core only allows for a single mode of travel for the light from one end of the cable to the other.</p>
<p lang="">SMF的芯尺寸為10微米。 SMF的較小芯線僅允許光從電纜一端到另一端的單一傳播模式。</p>
<p lang="">This straight-through connection allows for data to travel longer distances without a repeater than it can travel using MMF.</p>
<p lang="">這種直通連接允許數據在沒有中繼器的情況下傳輸的距離比使用MMF傳輸的距離更長。</p>
<p lang="">When the light reaches the destination, the signals are then converted back into 1s and 0s and passed to the computer by the network interface card.</p>
<p lang="">當光到達目的地時，信號然後被轉換回1和0，然後通過網絡接口卡傳遞到計算機。</p>
<p lang="">Single mode fiber is commonly used in very long distance fiber connections, such as a backbone connection from one local area network to another.</p>
<p lang="">單模光纖通常用於超長距離的光纖連接中，例如從一個局域網到另一個局域網的骨干連接。</p>
</div>
<h3>Fiber-Optic Cable Connectors光纖電纜連接器</h3>
<p id="N106B2" lang="">Fiber cables only come in the two types discussed above: single-mode and multimode. However, the ends of each of these cables come in four varieties.</p>
<p lang="">光纖電纜僅屬於上述兩種類型：單模和多模。但是，每條電纜的末端都有四種。</p>
<p id="N106B5" lang="">The subscriber connector (SC) is a fiber-optic cable connector that uses a push-pull mechanism to latch into the port, similar to common audio and video cables.</p>
<p lang="">用戶連接器（SC）是一種光纖電纜連接器，類似於普通的音頻和視頻電纜，它使用推挽機制鎖入端口。</p>
<p lang="">If you want to enable bidirectional transmission for sending and receiving data, you need to have two fiber cables, so sometimes a dual SC connector is used.</p>
<p lang="">如果要啟用雙向傳輸以發送和接收數據，則需要使用兩根光纖電纜，因此有時會使用雙SC連接器。</p>
<p id="N106B8" lang="">The straight tip (ST) connector is a fiber-optic cable connector that uses a bayonet plug and socket.</p>
<div class="tw-ta-container hide-focus-ring tw-lfl" id="tw-target-text-container" tabindex="0">
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">筆直（ST）連接器是使用卡口插頭和插座的光纖電纜連接器。</span></pre>
</div>
<p lang="">It was the first de facto standard connector for most commercial wiring using fiber cables and it is very commonly found in fiber networks.</p>
<p lang="">它是大多數使用光纖電纜進行商業佈線的第一個事實上的標準連接器，並且在光纖網絡中非常常見。</p>
<p id="N106BB" lang="">The Lucent connector (LC) is a miniaturized version of the fiber-optic SC connector.</p>
<p lang="">朗訊連接器（LC）是光纖SC連接器的微型版本。</p>
<p lang="">It looks somewhat like the SC, but is half the size, with a 1.25 mm ferrule instead of 2.5 mm, making it very useful when connecting multiple devices in a small area, such as on a 24-port switch’s front panel.</p>
<p lang="">它看上去有點像SC，但尺寸只有一半，只有1.25毫米而不是2.5毫米的套圈，因此在小區域（例如24端口交換機的前面板）連接多個設備時非常有用。</p>
<p id="N106BE" lang="">The mechanical transfer-registered jack (MT-RJ) connector is a fiber-optic cable connector that is very popular for small-form-factor devices due to its small size.</p>
<p lang="">機械傳輸註冊插孔（MT-RJ）連接器是一種光纖電纜連接器，由於其尺寸小，在小型設備中非常受歡迎。</p>
<p lang="">This connector houses two fibers and mates with locating pins on the plug.</p>
<p lang="">該連接器容納兩根光纖，並與插頭上的定位銷配對。</p>
<p lang="">These connectors are commonly found connecting a switch to a patch panel, because both devices have a limited area on their front panels.</p>
<p lang="">通常發現這些連接器將開關連接到配線架，因為兩個設備的前面板都有有限的區域。</p>
<h2>Twisted Pair Cable雙絞線</h2>
<p>傳送門:<a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed70a0001dc2a09c83ae8e59703">https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed70a0001dc2a09c83ae8e59703</a></p>
<h3>Twisted Pair Cable雙絞線</h3>
<p id="N1068B" lang="">While fiber-optic cable is great for its speed, distance, and security, it hasn’t yet become commonplace in most networks.</p>
<p lang="">儘管光纜在速度，距離和安全性方面都非常出色，但在大多數網絡中尚未普及。</p>
<p lang="">Instead, we are still using the same type of cabling we have been using for the past two to three decades — twisted pair.</p>
<p lang="">相反，我們仍在使用過去兩到三十年來一直使用的相同類型的電纜-雙絞線。</p>
<p lang="">Twisted pair cable is the most popular physical LAN media in the world today.</p>
<p lang="">雙絞線電纜是當今世界上最流行的物理LAN介質。</p>
<p lang="">Each cable contains four pairs of individually insulated strands of copper wire.</p>
<p lang="">每條電纜包含四對獨立絕緣的銅線。</p>
<p lang="">Each pair is twisted together to minimize the amount of electromagnetic interference (EMI).</p>
<p lang="">每對絞合在一起以最大程度地減少電磁干擾（EMI）。</p>
<p lang="">The more twists there are in the cable, the less EMI there will be. Twisted pair cable is broken up into two types: unshielded twisted pair (UTP) and shielded twisted pair (STP).</p>
<p>電纜中的扭曲越多，EMI越小。雙絞線電纜分為兩種類型：非屏蔽雙絞線（UTP）和屏蔽雙絞線（STP）。</p>
<p><img alt="" height="416" src="/images/image6.png" width="350"/></p>
<p id="N1069C" lang="">Shielded twisted pair cable is built very similarly to unshielded twisted pair, except that the pairs of wires are also surrounded by a metallic shielding (like foil).</p>
<p lang="">屏蔽雙絞線電纜的構造與非屏蔽雙絞線非常相似，不同的是，成對的電線也被金屬屏蔽層（如金屬箔）圍繞。</p>
<p lang="">This outer foil shielding minimizes the EMI to which the cable is exposed. This increases the security and reliability of the cable.</p>
<p lang="">外部箔屏蔽層可最大程度地減小電纜所遭受的EMI。這增加了電纜的安全性和可靠性。</p>
<p lang="">Unfortunately, however, this also increases the cost of the cable, so it is typically used only in high-production environments where the extra security is worth the extra cost.</p>
<p lang="">但是，不幸的是，這也增加了電纜的成本，因此通常僅在高生產環境中使用，在這種環境中，額外的安全性值得額外的成本。</p>
<p lang="">The more common type of cabling is unshielded twisted pair cable.</p>
<p lang="">電纜的最常見類型是非屏蔽雙絞線電纜。</p>
<p lang="">Instead of using extra shielding, this cable relies on the twisting of its copper pairs to minimize the effects of EMI.</p>
<p lang="">該電纜不使用額外的屏蔽，而是依靠其銅線對的絞合來最大程度地減小EMI的影響。</p>
<p lang="">Each twisted pair is twisted to insulate itself from the other pairs, and because there is no additional shielding, it is available at a lower cost than STP.</p>
<p lang="">每個雙絞線都經過絞合，以使其自身與其他雙絞線絕緣，並且由於沒有額外的屏蔽，因此可以以比STP更低的成本獲得。</p>
<p lang="">Therefore, UTP is the most common media of choice for small office, home office, residential, and many commercial networks.</p>
<p lang="">因此，UTP是小型辦公室，家庭辦公室，住宅和許多商業網絡中最常見的選擇媒體。</p>
<p lang=""><img alt="" height="570" src="/images/image7.png" width="418"/></p>
<h3>Categorizing Twisted Pair Cable分類雙絞線電纜</h3>
<p id="N106B9" lang="">Twisted pair cable is categorized based on a category (cat) number. For example, cat 3, or category 3, is the oldest type of cable that we use.</p>
<p lang=""></p>
<p lang="">It was introduced back in the 1980s and 1990s for use in the first star topologies. The maximum throughput or bandwidth of cat 3 cabling is only 10 Mbps (megabits per second).</p>
<p lang=""></p>
<p lang="">The cat 3, like all twisted pair cabling, cannot go farther than 100 meters without using a repeater, switch, or active hub to amplify the signal.</p>
<p lang=""></p>
<p lang="">This limited distance is attributable to the copper wiring in these cables.</p>
<p lang="">這種有限的距離歸因於這些電纜中的銅線。</p>
<p lang="">As the signal travels over the copper wire, the natural resistance to the wire decreases the signal’s strength, and it eventually becomes too weak for the distant end to receive.</p>
<p lang="">當信號在銅線上傳輸時，導線的固有電阻會降低信號的強度，最終變得太弱，無法接收到遠端。</p>
<p lang="">For this reason, there is a 100 meter limitation when building and designing a twisted pair network.</p>
<p lang="">因此，在構建和設計雙絞線網絡時存在100米的限制。</p>
<p id="N106BC" lang="">Cat 5 cables were an improvement on the older cat 3 cables and contain more twists, giving them more shielding from EMI and a maximum bandwidth of 100 Mbps.</p>
<p lang="">Cat 5電纜是對較舊的Cat 3電纜的改進，並包含更多的絞合線，從而使其具有更大的EMI屏蔽能力，最大帶寬為100 Mbps。</p>
<p lang="">Cat 5e, or cat 5 enhanced, increased the speed of the maximum throughput to one Gbps, or 1000 Mbps, and became a gap filler until cat 6 cabling became commonplace.</p>
<p lang="">Cat 5e或Cat 5增強後，將最大吞吐量的速度提高到1 Gbps或1000 Mbps，並成為了空白，直到Cat 6電纜變得司空見慣。</p>
<p id="N106BF" lang="">Cat 6a overcomes the 37-55 meter limitation of cat 6 when used in 10GBaseT. Cat 7, the newest standard, is shielded and provides connections up to 10 Gbps with a maximum distance of 100 meters.</p>
<p lang="">當在10GBaseT中使用時，Cat 6a克服了Cat 6的37-55米的限制。最新標準Cat 7被屏蔽，並提供高達10 Gbps的連接，最大距離為100米。</p>
<p lang="">“Cat 7 and cat 7a cabling will be used for backbone connections between servers within a data center” and “provide an alternative to using fiber-optic cabling within the data center” (from<a href="http://www.cablestogo.com/learning/library/data-center/cat7-overview" id="_i_4" lang="" target="_blank">http://www.cablestogo.com/learning/library/data-center/cat7-overview</a>).</p>
<p lang="">“ Cat 7和Cat 7a電纜將用於數據中心內服務器之間的主干連接”，並且“提供了在數據中心內使用光纖電纜的替代方法”</p>
<p id="N106C8" lang="">All cable categories up to cat 5e and cat 6a have a maximum distance of 100 meters.</p>
<p lang="">直至Cat 5e和Cat 6a為止的所有電纜類別的最大距離為100米。</p>
<p lang="">When used in 10GBaseT, the maximum distance for cat 6 is 55 meters.</p>
<p lang="">在10GBaseT中使用時，類別6的最大距離為55米。</p>
<p lang="">Cat 7 is shielded and exceeds the 100 meter limit.</p>
<p lang="">Cat 7被屏蔽並超過了100米的限制。</p>
<p lang="">As the category of the cable increases, so do the number of twists per inch and the frequency range, allowing for more data and improved protection against EMI.</p>
<p lang="">隨著電纜類別的增加，每英寸的捻數和頻率範圍也會增加，從而可以提供更多的數據並改善對EMI的保護。</p>
<p lang="">Best practice for copper cabling is<span> </span><em class="italic" lang="">not<span> </span></em>to run cable lengths to the maximum because attenuation will reduce data capacity.</p>
<p lang="">銅纜佈線的最佳實踐是不要使電纜長度最大，因為衰減會降低數據容量。</p>
<p lang=""><img alt="" height="253" src="/images/螢幕擷取畫面 2020-10-18 233714.png" width="632"/></p>
<h3>Twisted Pair Connectors雙絞線連接器</h3>
<p id="N10735" lang="">Twisted pair cables come with three main types of connectors.</p>
<p lang="">雙絞線電纜帶有三種主要類型的連接器。</p>
<p lang="">The first is the RJ-45 connector, which is an eight-pin connector used in Ethernet networks.</p>
<p lang="">第一個是RJ-45連接器，它是以太網網絡中使用的八針連接器。</p>
<p lang="">Even though most Ethernet networks use only four pins, the RJ-45 provides eight pins for future use and capabilities.</p>
<p lang="">即使大多數以太網僅使用四個引腳，RJ-45仍提供八個引腳以供將來使用和使用。</p>
<p lang="">The first four pins are used to transmit (two pins) and receive (two pins).</p>
<p lang="">前四個引腳用於發送（兩個引腳）和接收（兩個引腳）。</p>
<p id="N10738" lang="">The RJ-11 connector is used in the standard telephone system.</p>
<p lang="">RJ-11連接器用於標準電話系統。</p>
<p lang="">The RJ-11 is a six-pin connector, but commonly only two pins are used for a telephone (transmit and receive).</p>
<p lang="">RJ-11是一個六針連接器，但電話通常僅使用兩個針（發送和接收）。</p>
<p lang="">If you have a two-line phone, then four pins are used: two pins to transmit and two pins to receive.</p>
<p lang="">如果您有兩線電話，則使用四個引腳：兩個引腳用於發送，兩個引腳用於接收。</p>
<p id="N1073B" lang="">Finally, the DB-9 connector is used for RS-232 signals.</p>
<p lang="">最後，DB-9連接器用於RS-232信號。</p>
<p lang="">This connector looks like a standard serial connector. It is used commonly for asynchronous serial communications, like connecting to an external modem.</p>
<p lang="">該連接器看起來像標準的串行連接器。它通常用於異步串行通信，例如連接到外部調製解調器。</p>
<p lang="">In modern networks, you will see this type of connector on a “rollover cable.”</p>
<p lang="">在現代網絡中，您將在“翻轉電纜”上看到這種類型的連接器。</p>
<p lang="">A rollover cable has a DB-9 on one side (which is connected to your laptop’s serial port), and an RJ-45 connector on the other side (which is used to connect to Cisco routers and switches to do administration tasks).</p>
<p lang="">翻轉電纜的一側為DB-9（連接到筆記本電腦的串行端口），另一側為RJ-45連接器（用於連接到Cisco路由器和交換機以執行管理任務）。</p>
<p id="N1073E" lang="">A straight-through cable is a type of twisted pair cable that is used in local area networks to connect a computer to a network hub, such as a router.</p>
<p lang="">直通電纜是雙絞線電纜的一種，在局域網中用於將計算機連接到網絡集線器（例如路由器）。</p>
<p lang="">This type of cable is also sometimes called a patch cable.</p>
<p lang="">此類電纜有時也稱為跳線。</p>
<p lang="">Both ends of the cable have an identical pinout, hence the name “straight-through.” A crossover cable switches the pinouts of the two ends of the cable, making the transmit and receive pins alternate on the two ends. This allows two workstations to connect directly to each other without the need for a hub, switch, or router.</p>
<p lang="">電纜的兩端都具有相同的引出線，因此名稱為“直通”。交叉電纜切換電纜兩端的引腳分配，使發送和接收引腳在兩端交替。這允許兩個工作站直接相互連接，而無需集線器，交換機或路由器。</p>
<p lang=""><img alt="" height="500" src="/images/image8.png" width="500"/></p>
<h3>Categorizing Twisted Pair Cable分類雙絞線電纜</h3>
<p id="N106B9" lang="">Twisted pair cable is categorized based on a category (cat) number. For example, cat 3, or category 3, is the oldest type of cable that we use.</p>
<p lang="">雙絞線電纜根據類別（類別）編號進行分類。例如，類別3（或類別3）是我們使用的最古老的電纜類型。</p>
<p lang="">It was introduced back in the 1980s and 1990s for use in the first star topologies.</p>
<p lang="">它是在1980年代和1990年代引入的，用於第一批星形拓撲。</p>
<p lang="">The maximum throughput or bandwidth of cat 3 cabling is only 10 Mbps (megabits per second).</p>
<p lang="">Cat 3電纜的最大吞吐量或帶寬僅為10 Mbps（兆位/秒）。</p>
<p lang="">The cat 3, like all twisted pair cabling, cannot go farther than 100 meters without using a repeater, switch, or active hub to amplify the signal.</p>
<p lang="">與所有雙絞線電纜一樣，如果不使用中繼器，交換機或有源集線器來放大信號，則Cat 3不能走超過100米。</p>
<p lang="">This limited distance is attributable to the copper wiring in these cables.</p>
<p lang="">這種有限的距離歸因於這些電纜中的銅線。</p>
<p lang="">As the signal travels over the copper wire, the natural resistance to the wire decreases the signal’s strength, and it eventually becomes too weak for the distant end to receive.</p>
<p lang="">當信號在銅線上傳輸時，導線的固有電阻會降低信號的強度，最終變得太弱，無法接收到遠端。</p>
<p lang="">For this reason, there is a 100 meter limitation when building and designing a twisted pair network.</p>
<p lang="">因此，在構建和設計雙絞線網絡時存在100米的限制。</p>
<p id="N106BC" lang="">Cat 5 cables were an improvement on the older cat 3 cables and contain more twists, giving them more shielding from EMI and a maximum bandwidth of 100 Mbps.</p>
<p lang="">Cat 5電纜是對較舊的Cat 3電纜的改進，並包含更多的絞合線，從而使其具有更大的EMI屏蔽能力，最大帶寬為100 Mbps。</p>
<p lang="">Cat 5e, or cat 5 enhanced, increased the speed of the maximum throughput to one Gbps, or 1000 Mbps, and became a gap filler until cat 6 cabling became commonplace.</p>
<p lang="">Cat 5e或Cat 5增強後，將最大吞吐量的速度提高到1 Gbps或1000 Mbps，並成為了空白，直到Cat 6電纜變得司空見慣。</p>
<p id="N106BF" lang="">Cat 6a overcomes the 37-55 meter limitation of cat 6 when used in 10GBaseT.</p>
<p lang="">當在10GBaseT中使用時，Cat 6a克服了Cat 6的37-55米的限制。</p>
<p lang="">Cat 7, the newest standard, is shielded and provides connections up to 10 Gbps with a maximum distance of 100 meters.</p>
<p lang="">最新標準Cat 7被屏蔽，並提供高達10 Gbps的連接，最大距離為100米。</p>
<p lang="">“Cat 7 and cat 7a cabling will be used for backbone connections between servers within a data center” and “provide an alternative to using fiber-optic cabling within the data center” (from<a href="http://www.cablestogo.com/learning/library/data-center/cat7-overview" id="_i_4" lang="" target="_blank">http://www.cablestogo.com/learning/library/data-center/cat7-overview</a>).</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">“ Cat 7和Cat 7a電纜將用於數據中心內服務器之間的骨干連接”，並“提供在數據中心內使用光纖電纜的替代方法”</span></pre>
<p id="N106C8" lang="">All cable categories up to cat 5e and cat 6a have a maximum distance of 100 meters. When used in 10GBaseT, the maximum distance for cat 6 is 55 meters.</p>
<p lang="">直至Cat 5e和Cat 6a為止的所有電纜類別的最大距離為100米。在10GBaseT中使用時，類別6的最大距離為55米。</p>
<p lang="">Cat 7 is shielded and exceeds the 100 meter limit.</p>
<p lang="">Cat 7被屏蔽並超過了100米的限制。</p>
<p lang="">As the category of the cable increases, so do the number of twists per inch and the frequency range, allowing for more data and improved protection against EMI.</p>
<p lang="">隨著電纜類別的增加，每英寸的捻數和頻率範圍也會增加，從而可以提供更多的數據並改善對EMI的保護。</p>
<p lang="">Best practice for copper cabling is<span> </span><em class="italic" lang="">not<span> </span></em>to run cable lengths to the maximum because attenuation will reduce data capacity.</p>
<p lang="">銅纜佈線的最佳實踐是不要使電纜長度最大，因為衰減會降低數據容量。</p>
<p lang=""><img alt="" height="253" src="/images/螢幕擷取畫面 2020-10-18 233714.png" width="632"/></p>
<h3>Twisted Pair Connectors雙絞線連接器-1</h3>
<div class="tw-ta-container hide-focus-ring tw-nfl" id="tw-target-rmn-container">
<p id="N10735" lang="">Twisted pair cables come with three main types of connectors.</p>
<p lang="">雙絞線電纜帶有三種主要類型的連接器。</p>
<p lang="">The first is the RJ-45 connector, which is an eight-pin connector used in Ethernet networks.</p>
<p lang="">第一個是RJ-45連接器，它是以太網網絡中使用的八針連接器。</p>
<p lang="">Even though most Ethernet networks use only four pins, the RJ-45 provides eight pins for future use and capabilities.</p>
<p lang="">即使大多數以太網僅使用四個引腳，RJ-45仍提供八個引腳以供將來使用和使用。</p>
<p lang="">The first four pins are used to transmit (two pins) and receive (two pins).</p>
<p lang="">前四個引腳用於發送（兩個引腳）和接收（兩個引腳）。</p>
<p id="N10738" lang="">The RJ-11 connector is used in the standard telephone system.</p>
<p lang="">RJ-11連接器用於標準電話系統。</p>
<p lang="">The RJ-11 is a six-pin connector, but commonly only two pins are used for a telephone (transmit and receive).</p>
<p lang="">RJ-11是一個六針連接器，但電話通常僅使用兩個針（發送和接收）。</p>
<p lang="">If you have a two-line phone, then four pins are used: two pins to transmit and two pins to receive.</p>
<p lang="">如果您有兩線電話，則使用四個引腳：兩個引腳用於發送，兩個引腳用於接收。</p>
<p id="N1073B" lang="">Finally, the DB-9 connector is used for RS-232 signals.</p>
<p lang="">最後，DB-9連接器用於RS-232信號。</p>
<p lang="">This connector looks like a standard serial connector. It is used commonly for asynchronous serial communications, like connecting to an external modem.</p>
<p lang="">該連接器看起來像標準的串行連接器。它通常用於異步串行通信，例如連接到外部調製解調器。</p>
<p lang="">In modern networks, you will see this type of connector on a “rollover cable.” A rollover cable has a DB-9 on one side (which is connected to your laptop’s serial port), and an RJ-45 connector on the other side (which is used to connect to Cisco routers and switches to do administration tasks).</p>
<p lang="">在現代網絡中，您將在“翻轉電纜”上看到這種類型的連接器。翻轉電纜的一側為DB-9（連接到筆記本電腦的串行端口），另一側為RJ-45連接器（用於連接到Cisco路由器和交換機以執行管理任務）。</p>
<p id="N1073E" lang="">A straight-through cable is a type of twisted pair cable that is used in local area networks to connect a computer to a network hub, such as a router.</p>
<p lang="">直通電纜是雙絞線電纜的一種，在局域網中用於將計算機連接到網絡集線器（例如路由器）。</p>
<p lang="">This type of cable is also sometimes called a patch cable.</p>
<p lang="">此類電纜有時也稱為跳線。</p>
<p lang="">Both ends of the cable have an identical pinout, hence the name “straight-through.” A crossover cable switches the pinouts of the two ends of the cable, making the transmit and receive pins alternate on the two ends.</p>
<p lang="">電纜的兩端都具有相同的引出線，因此名稱為“直通”。交叉電纜切換電纜兩端的引腳分配，使發送和接收引腳在兩端交替。</p>
<p lang="">This allows two workstations to connect directly to each other without the need for a hub, switch, or router.</p>
<p lang="">這允許兩個工作站直接相互連接，而無需集線器，交換機或路由器。<img alt="" height="500" src="/images/image8.png" width="500"/></p>
<h2>Coaxial Cable同軸電纜</h2>
<p><a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed80a0001dc2e85178ac6debe3c">傳送門:https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ed80a0001dc2e85178ac6debe3c</a></p>
<h3>Coaxial Cable同軸電纜</h3>
<p><span>Coaxial cable is a much older media technology.</span></p>
<p><span>同軸電纜是一種較老的媒體技術。</span></p>
<p><span> Coaxial cable, also known as coax for short, is composed of two conductors.</span></p>
<p><span>同軸電纜，也簡稱為同軸電纜，由兩個導體組成。</span></p>
<p><span> The inner conductor, which is known as the insulated conductor (center wire), is the copper wire over which data is passed. </span></p>
<p><span>內部導體（稱為絕緣導體（中心線））是在其上傳遞數據的銅線。</span></p>
<p><span>The outer conductor is the braided metal shield and aids in protecting the inner wire from physi</span>cal injury and the effects of EMI.</p>
<p>外導體是編織的金屬屏蔽層，有助於保護內線免受物理傷害和EMI的影響。</p>
<p>Much like the shielding we saw in shielded twisted pair, the outer shield helps keep electromagnetic interference out of the data’s path.</p>
<p>就像我們在屏蔽雙絞線中看到的屏蔽一樣，外部屏蔽有助於將電磁干擾排除在數據路徑之外。</p>
<p>Between the inner conductor and the outer shield, we find an insulated core that prevents any data transfer between the inner core and outer shield.</p>
<p>在內部導體和外部屏蔽層之間，我們找到了一個絕緣芯，可防止在內芯和外部屏蔽層之間進行任何數據傳輸。</p>
<p>The outside of the cable is made of a flexible plastic jacket, much like the twisted pair cabling.</p>
<p>電纜的外部由柔軟的塑料護套製成，非常類似於雙絞線電纜。</p>
<p>Coaxial cabling was included in the first Ethernet standard as 10Base5 (thicknet) and continued to be used throughout updates as 10Base2 (thinnet) as well as being most commonly used in bus and ring networks.</p>
<p>同軸電纜已包含在第一個以太網標準中，稱為10Base5（Thicknet），並在整個更新中繼續用作10Base2（Thinnet），並在總線和環形網絡中最常用。</p>
<p>UTP cabling however, is easier to work with in a star topology and is significantly less expensive.</p>
<p>但是，UTP電纜更容易在星形拓撲中使用，並且價格便宜得多。</p>
<p><img alt="" height="424" src="/images/image9.png" width="299"/></p>
<h3>Coaxial Cable Types同軸電纜類型</h3>
<div class="section" id="N106A2">
<div class="sectionContain">
<p id="N106A9" lang="">There are three dominant coaxial cable types.</p>
<p lang="">共有三種主要的同軸電纜類型。</p>
<p lang="">The RG-6 is commonly used by cable TV companies to connect individual homes to the TV network.</p>
<p lang="">有線電視公司通常使用RG-6將單個房屋連接到電視網絡。</p>
<p lang="">These cables are thick and usually used for outside connections to withstand the effects of the weather.</p>
<p lang="">這些電纜很粗，通常用於外部連接以承受天氣的影響。</p>
<p lang="">The RG-58 is a type of coaxial cable that was heavily used in early 10Base2 (thinnet) networks, such as bus and ring topologies.</p>
<p lang="">RG-58是一種同軸電纜，在諸如總線和環形拓撲之類的早期10Base2（瘦網）網絡中大量使用。</p>
<p lang="">Finally, the RG-59 is the traditional coaxial cable used to carry composite video between two nearby devices, such as your TV and the cable box.</p>
<p lang="">最後，RG-59是傳統的同軸電纜，用於在兩個附近的設備（例如電視和電纜盒）之間傳送複合視頻。</p>
<p lang="">If you are a cable Internet user, this is also used to carry the WAN connection from your wall jack to your cable modem.</p>
<p lang="">如果您是有線Internet用戶，這也可用於將WAN連接從牆壁插孔連接到電纜調製解調器。</p>
<h3>Coaxial Cable Connectors同軸電纜連接器</h3>
<p id="N106B5" lang="">While there were three types of cables, there are only two types of common connectors used with coaxial cable.</p>
<p lang="">雖然有三種類型的電纜，但同軸電纜僅使用兩種類型的普通連接器。</p>
<p lang="">The first is called BNC, from the name Bayonet Neill-Concelman.</p>
<p lang="">第一個稱為BNC，名稱為<span>尼爾-康塞曼卡口(Bayonet Neill-Concelman)</span>。</p>
<p lang="">Sometimes people also call this the British Naval connector, because the BNC was heavily used by the British in their shipboard radio systems.</p>
<p lang="">有時人們也將其稱為英國海軍連接器，因為英國人在其艦載無線電系統中大量使用了BNC。</p>
<p lang="">This connector was commonly used in early Ethernet networks and it has a “push and twist” type of connector to secure the cable to the network device.</p>
<p lang="">該連接器通常用於早期的以太網網絡，並且具有“推壓式”連接器，用於將電纜固定至網絡設備。</p>
<p id="N106B8" lang="">The F-type connector is the modern type of coaxial cable connector.</p>
<p lang="">F型連接器是現代類型的同軸電纜連接器。</p>
<p lang="">It is typically used for cable TV and cable modem connections.</p>
<p lang="">它通常用於有線電視和電纜調製解調器的連接。</p>
<p lang="">It is connected by screwing the connector onto a threaded jack to secure the connection.</p>
<p lang="">通過將連接器擰到帶螺紋的插孔上進行連接以固定連接。</p>
<p lang=""><img alt="" height="330" src="/images/image10.png" width="290"/></p>
<h2>Copper vs Fiber銅與光纖</h2>
<p><span>When we compare the advantages and disadvantages of fiber-optic cables and copper (twisted pair) cables, we have to consider that fiber-optic has a higher bandwidth (measured in Gbps or Tbps), it can carry its signal many miles without the need of a repeater, it is immune to the effects of EMI, and it has much better security than traditional twisted pair cables.</span></p>
<p><span>當我們比較光纖電纜和銅纜（雙絞線）的優缺點時，我們必須考慮到光纖具有更高的帶寬（以Gbps或Tbps為單位），它可以將其信號傳輸很多英里而無需作為中繼器，它不受EMI的影響，並且比傳統的雙絞線電纜具有更好的安全性。</span></p>
<p><span> However, twisted pair cabling does hold some advantages of its own. For one, it is much less expensive than fiber-optic cabling. </span></p>
<p><span>但是，雙絞線電纜確實具有其自身的一些優點。首先，它比光纖電纜便宜得多。</span></p>
<p><span>Also, copper wiring is much easier to install, taking only a few hours to learn. Finally, twisted pair cabling can be created and terminated using inexpensive tools.</span></p>
<p><span>而且，銅線的安裝更容易，只需幾個小時即可學習。最後，可以使用廉價的工具創建和終止雙絞線電纜。</span></p>
<p><span> For example, a complete copper wiring toolset can be bought online for less than $50, while a complete fiber-optic kit may cost $1000 or more. For these reasons, copper has remained the dominant media in most local area networks.</span></p>
<p><span>例如，一套完整的銅線工具套件可以在線購買，價格不到50美元，而一套完整的光纖套件的價格可能在1000美元以上。由於這些原因，銅一直是大多數局域網中的主要介質。</span></p>
<h2>Converters轉換器</h2>
<p id="N10678" lang="">Because of the wide variety of cable and connector types, there is sometimes a need to convert from one type of media to another.</p>
<p lang="">由於電纜和連接器的類型多種多樣，因此有時需要從一種類型的媒體轉換為另一種類型的媒體。</p>
<p lang="">For example, if you have to make a connection between two LANs in buildings that are located one mile apart, but your network uses Cat 5e, UTP cabling, how can you make that connection?</p>
<p lang="">例如，如果您必須在相距一英里的建築物中的兩個LAN之間建立連接，但是您的網絡使用Cat 5e，UTP電纜，那麼如何建立連接？</p>
<p lang="">When you look at your routers, you find they only accept RJ-45 connections, but you know that you cannot run a Cat 5e cable more than 100 meters.</p>
<p lang="">當您查看路由器時，會發現它們僅接受RJ-45連接，但是您知道不能將Cat 5e電纜的長度超過100米。</p>
<p lang="">How can you solve this problem? With a media converter.</p>
<p lang="">您如何解決這個問題？用媒體轉換器嗎?</p>
<p id="N1067B" lang="">Using a media converter, you can convert your RJ-45 connection into an ST, SC, or LC fiber connection, as shown in the image below.</p>
<p lang="">使用媒體轉換器，您可以將RJ-45連接轉換為ST，SC或LC光纖連接，如下圖所示。</p>
<p lang="">Then, you run the one-mile fiber cable to the other building, and use a media converter to convert from the ST, SC, or LC fiber connection back to the RJ-45 the other router requires. Because this is a simple, “dumb” device, it simply converts whatever is received on the first media type and repeats it back out the second media type.</p>
<p lang="">然後，將一英里的光纜連接到另一座建築物，並使用媒體轉換器將ST，SC或LC光纖連接轉換回另一台路由器所需的RJ-45。因為這是一個簡單的“啞”設備，所以它僅轉換在第一媒體類型上接收到的所有內容，然後將其重複播放回第二媒體類型。</p>
<p lang="">Common types of media converters are from Ethernet (copper) to fiber-optic (and back) or coaxial to fiber-optic (and back).</p>
<p lang="">媒體轉換器的常見類型是從以太網（銅）到光纖（然後向後）或同軸到光纖（然後向後）。</p>
<p lang=""><img alt="" height="288" src="/images/image11.png" width="300"/></p>
<h1>PCH 12 Ethernet Standards</h1>
<p><a href="https://oli.cmu.edu/jcourse/webui/syllabus/module.do?context=d87f2ef40a0001dc17e61c60be4f3aed">傳送門:https://oli.cmu.edu/jcourse/webui/syllabus/module.do?context=d87f2ef40a0001dc17e61c60be4f3aed</a></p>
<h2>Overview總覽</h2>
<p><span>In this module, we are going to discuss how the various Ethernet standards developed over time.</span></p>
<p><span>在本模塊中，我們將討論隨著時間的推移如何開發各種以太網標準。</span></p>
<p><span> We will also discuss why there is a need for these standards and the effect of these standards on the industry.</span></p>
<p><span>我們還將討論為什麼需要這些標準以及這些標準對行業的影響。</span></p>
<p><span> In addition, we are going to cover various types of network media standards. We will cover 10Base-T (802.3i, 1990) as well as 100Base-T and 1000Base-T (1GBASE-T or 1 GigE) Ethernet standards, which are most commonly found in current office networks. </span></p>
<p><span>另外，我們將涵蓋各種類型的網絡媒體標準。我們將介紹10Base-T（802.3i，1990）以及100Base-T和1000Base-T（1GBASE-T或1 GigE）以太網標準，它們是當前辦公網絡中最常見的標準。</span></p>
<p><span>We will discover how to plan a basic network connection using 100BaseT. Finally, we will cover differences between Ethernet and TCP/IP.</span></p>
<p><span>我們將發現如何使用100BaseT規劃基本的網絡連接。最後，我們將介紹以太網和TCP / IP之間的差異。</span></p>
<h2>Ethernet Technology以太網技術</h2>
<p id="N10690" lang="">Before Ethernet was the dominant technology, there were multiple types of networking technologies competing for market share.</p>
<p lang="">在以太網成為主導技術之前，存在多種類型的網絡技術爭奪市場份額。</p>
<p lang="">At one point, Ethernet was just one of many competing standards, including token ring, fiber distributed data interface (FDDI), and more.</p>
<p lang="">一方面，以太網只是眾多競爭標準之一，包括令牌環，光纖分佈式數據接口（FDDI）等。</p>
<p lang="">By the late 1990s, a single standard was clearly the dominant choice in both office and residential networks: IEEE 802.3 Ethernet.</p>
<p lang="">到1990年代後期，單一標準顯然已成為辦公和住宅網絡中的主要選擇：IEEE 802.3以太網。</p>
<p lang="">Ethernet uses various media types, from coaxial cable to twisted-pair copper and fiber-optic cables (discussed in an earlier module).</p>
<p lang="">以太網使用各種介質類型，從同軸電纜到雙絞銅纜和光纖電纜（在較早的模塊中討論）。</p>
<p lang="">The 802.3 Ethernet standard and the concept of using frames for communication over various media, including Wireless 802.11, is predominant today, and it is vital to understand the fundamentals of Ethernet including the various speed and distance limitations each standard places on our networks.</p>
<p lang="">802.3以太網標準和使用幀在包括無線802.11在內的各種媒體上進行通信的概念如今非常盛行，了解以太網的基本知識（包括每個標準對我們網絡的各種速度和距離限制）至關重要。</p>
<p id="N10693" lang="">The original 802.3 Ethernet standard sent data over coaxial cables at a half-duplex transmission rate which means devices can only transmit (TX) or Receive (RX) alternately at separate intervals because the data used the same path for both.</p>
<p lang="">最初的802.3以太網標準以半雙工傳輸速率通過同軸電纜發送數據，這意味著設備只能以單獨的間隔交替發送（TX）或接收（RX），因為這兩個數據使用相同的路徑。</p>
<p lang="">This is analagous to communicating using a walkie-talkie rather than a telephone.</p>
<p lang="">這類似於使用對講機而不是電話進行通信。</p>
<p id="N10696" lang="">This coaxial cable design became known as Thicknet and later Thinnet due to the size of the cables and was mostly used in bus and ring network topologies.</p>
<p lang="">由於電纜的尺寸，這種同軸電纜設計被稱為Thinnet，後來被稱為Thinnet，並且主要用於總線和環形網絡拓撲中。</p>
<p id="N10699" lang="">Thicknet, the original IEEE 802.3 standard designated as 10Base5, provided a maximum bandwidth of 10Mbps and was limited in distance to 500 meters.</p>
<p lang="">最初被指定為10Base5的IEEE 802.3標準Thicknet提供的最大帶寬為10Mbps，並且距離限制為500米。</p>
<p lang="">Thinnet, or IEEE 10Base2, used a smaller type of coaxial and also provided a maximum bandwidth of 10 Mbps, but was limited to 185 meters.</p>
<p lang="">Thinnet或IEEE 10Base2使用較小類型的同軸電纜，並且提供的最大帶寬為10 Mbps，但限制為185米。</p>
<p lang="">Eventually the industry transitioned from coaxial cabling to unshielded twisted-pair cabling.</p>
<p lang="">最終，該行業從同軸電纜過渡到非屏蔽雙絞線電纜。</p>
<p id="N1069C" lang="">Twisted pair cabling, dubbed 10BaseT, provided the same 10 Mbps half-duplex maximum bandwidth with a category 3 cable, but the distance was limited to 100 meters due to the lack of the extra shield that coaxial provided.</p>
<p lang="">雙絞線電纜（稱為10BaseT）與第3類電纜可提供相同的10 Mbps半雙工最大帶寬，但由於缺少同軸電纜提供的額外屏蔽，因此距離限制為100米。</p>
<p lang="">In spite of the increased attenuation (loss of signal strength over distance), network designers moved to twisted pair cabling because of ease of installation and overall lower cost.</p>
<p lang="">儘管衰減增加（信號強度隨著距離的增加而損失），但由於易於安裝且總體成本較低，網絡設計人員仍選擇雙絞線佈線。</p>
<p lang="">Coaxial cable fell out of favor and the 802.3 Ethernet standard continues to evolve with faster data rates over twisted pair cabling categories.</p>
<p lang="">同軸電纜不受歡迎，並且802.3以太網標準繼續發展，雙絞線佈線類別的數據速率更快。</p>
<p id="N1069F" lang="">The design question that Ethernet had to answer was how a device should access the network.</p>
<p lang="">以太網必須回答的設計問題是設備應如何訪問網絡。</p>
<p lang="">The nature of half-duplex transmission (TX or RX) over a single wire pair meant that collisions were imminent.</p>
<p lang="">單線對上半雙工傳輸（TX或RX）的性質意味著即將發生衝突。</p>
<p lang="">Should the access be deterministic and orderly, or contention-based and chaotic?</p>
<p lang="">訪問應該是確定性和有序的，還是基於競爭的且混亂的？</p>
<p lang="">The older ring-based networks, such as token ring, were developed upon the premise that order was necessary: each machine would wait for its turn to transmit its data until it received the electronic token that was passed around the ring.</p>
<p lang="">較舊的基於環的網絡（例如令牌環）是在必須有順序的前提下開發的：每台機器都將等待其輪流發送其數據，直到接收到圍繞環傳遞的電子令牌。</p>
<p lang="">This is similar to the “talking stick” or “speaker’s staff” used by Native Americans and other aboriginal tribes where the staff (token) gave the person access to speak and the remaining group members listened. Ethernet, on the other hand, is premised upon a contention-based model.</p>
<p lang="">這類似於美洲原住民和其他原住民部落使用的“說話棒”或“發言人的工作人員”，其中工作人員（令牌）使該人員可以發言，其餘的小組成員則可以收聽。另一方面，以太網以基於競爭的模型為前提。</p>
<p lang="">This is more chaotic and allows any device on the network to transmit anytime it wishes.</p>
<p lang="">這更加混亂，並允許網絡上的任何設備在其希望的任何時間進行傳輸。</p>
<p lang="">The problem with this type of philosophy is figuring out how to prevent two devices from transmitting at the same time and causing a collision of the data.</p>
<p lang="">這種類型的原理存在的問題是，要弄清楚如何防止兩個設備同時傳輸並導致數據衝突。</p>
<p lang="">With Ethernet, the answer came in the form of a media access control method called carrier sense multiple access/collision detect (CSMA/CD).</p>
<p lang="">對於以太網，答案是以一種稱為載波偵聽多路訪問/衝突檢測（CSMA / CD）的媒體訪問控制方法的形式出現的。</p>
<h2>Carrier Sense Multiple Access&amp;Collision Detect載波偵聽多路訪問和衝突檢測</h2>
<p id="N10698" lang="">The nature of half-duplex transmission brought about the need for CSMA/CD, which works by allowing all devices to transmit data whenever they wish.</p>
<p lang="">半雙工傳輸的性質帶來了對CSMA / CD的需求，它允許所有設備在需要時傳輸數據。</p>
<p lang="">The carrier sense portion means that the device “listens” to the network first to find a “break” in the conversation.</p>
<p lang="">運營商感知部分意味著設備首先“監聽”網絡以在會話中找到“中斷”。</p>
<p lang="">If the device doesn’t hear other devices transmitting, then it begins its transmission.</p>
<p lang="">如果該設備聽不到其他設備的傳輸，則開始傳輸。</p>
<p lang="">Multiple access refers to every device having equal access to the network at all times.</p>
<p lang="">多路訪問是指每台設備始終具有對網絡的平等訪問權限。</p>
<p lang="">This is unlike the token ring network in which each device had to wait for the signal (token) before transmitting.</p>
<p lang="">這與令牌環網絡不同，在令牌環網絡中，每個設備都必須在發送之前等待信號（令牌）。</p>
<p lang="">Finally, we have collision detection as part of the CSMA/CD control method.</p>
<p lang="">最後，我們將碰撞檢測作為CSMA / CD控制方法的一部分。</p>
<p lang="">If, by chance, two devices both were ready to transmit, they “listened” to the network for a “lull” in the conversation, and both started transmitting at the same time, the devices are able to detect that they both transmitted at the same time and caused a collision.</p>
<p lang="">如果偶然地兩個設備都準備好發送，則它們在通話中“偵聽”網絡中的“失敗”，並且兩個設備都同時開始發送，則這些設備能夠檢測到它們都在發送時發送。同時又造成了碰撞。</p>
<p id="N1069B" lang="">The image below depicts both the CSMA/CD and CSMA/CA simplified algorithm.</p>
<p lang="">下圖描述了CSMA / CD和CSMA / CA簡化算法。</p>
<p lang="">The left branch is CSMA/CD used by half-duplex Ethernet and the right branch is CSMA/CA used by 802.11 wireless LAN, which is also half-duplex.</p>
<p lang="">左分支是半雙工以太網使用的CSMA / CD，右分支是802.11無線LAN（也是半雙工）使用的CSMA / CA。</p>
<p lang=""><img alt="" height="749" src="/images/image1.png" width="769"/></p>
<p lang=""><span>In the example shown below, four devices are connected in a physical bus topology. Each device has equal access to the network.</span></p>
<p lang=""><span>在下面顯示的示例中，四個設備以物理總線拓撲連接。每個設備對網絡都有平等的訪問權限。</span></p>
<p lang=""><span> Here, all the devices are listening, trying to determine if any other device is communicating before beginning transmission.</span></p>
<p lang=""><span>在這裡，所有設備都在監聽，試圖確定是否有其他設備在開始傳輸之前進行通信。</span></p>
<p lang=""><span><img alt="" height="488" src="/images/image2.png" width="700"/></span></p>
<p id="N106CA" lang="">In the next image below, we see an example of two devices that transmitted at the same time.</p>
<p lang="">在下一張圖片中，我們看到了兩個同時傳輸的設備的示例。</p>
<p lang="">This simultaneous transmission resulted in a data collision, causing the transmission to be broken.</p>
<p lang="">這種同時傳輸導致數據衝突，導致傳輸中斷。</p>
<p lang=""><img alt="" height="488" src="/images/image3.png" width="700"/></p>
<p id="N106DB" lang="">When a collision is detected, both devices choose a backoff time at random, and then attempt to retransmit again.</p>
<p lang="">當檢測到衝突時，兩個設備都會隨機選擇一個退避時間，然後嘗試重新傳輸。</p>
<p lang="">In the diagram below, the computers choose to wait 200 milliseconds and 300 milliseconds, respectively.</p>
<p lang="">在下圖中，計算機分別選擇等待200毫秒和300毫秒。</p>
<p lang="">When that time is up, they will attempt to sense if another machine is already transmitting.</p>
<p lang="">時間到時，他們將嘗試檢測另一台機器是否已經在傳輸。</p>
<p lang="">If there is nothing detected, the first machine will transmit its message. Once completed, the second machine will then transmit its message, after its 300 millisecond wait time.</p>
<p lang="">如果未檢測到任何內容，則第一台機器將發送其消息。一旦完成，第二台機器將在其300毫秒的等待時間之後發送其消息。</p>
<p lang=""><img alt="" height="488" src="/images/image4.png" width="700"/></p>
<p lang="">Recovering from a collision with random backup timers.</p>
<p lang="">使用隨機備份計時器從衝突中恢復。</p>
<h2>Evolution of Standards標準的演變</h2>
<p id="N10690" lang="">Finally, we need to discuss the various standards we use in Ethernet in terms of bandwidth and distance limitations.</p>
<p lang="">最後，我們需要討論帶寬和距離限制方面在以太網中使用的各種標準。</p>
<p id="N10693" lang="">The Ethernet standard also determines the type of cable, its bandwidth, and its distance limitation.</p>
<p lang="">以太網標準還確定電纜的類型，帶寬和距離限制。</p>
<p lang="">It is important to know these standards, especially those that relate to a category 3, 5, 5e, and 6 cabling standard.</p>
<p lang="">重要的是要知道這些標準，尤其是與3、5、5e和6類佈線標準有關的標準。</p>
<p lang=""><img alt="" height="361" src="/images/螢幕擷取畫面 2020-10-25 232802.png" width="596"/></p>
<p lang=""><span>When discussing data flow and speed, the two terms referred to are bandwidth and throughput. </span></p>
<p lang=""><span>在討論數據流和速度時，所指的兩個術語是帶寬和吞吐量。</span></p>
<p lang=""><span>Often used interchangeably, the two terms are different and need to be understood. </span></p>
<p lang=""><span>這兩個術語通常可以互換使用，它們是不同的，需要理解。</span></p>
<p lang=""><span>Simply put, bandwidth is the theoretical maximum of the given standard, whereas throughput is the actual potential in a real-world scenario. </span></p>
<p lang=""><span>簡而言之，帶寬是給定標準的理論最大值，而吞吐量是實際情況下的實際潛力。</span></p>
<p lang=""><span>Many factors affect actual throughput, such as half-duplex vs. full-duplex, cable length, and quality. </span></p>
<p lang=""><span>許多因素會影響實際吞吐量，例如半雙工與全雙工，電纜長度和質量。</span></p>
<p lang=""><span>Both bandwidth and throughput are measured in bits per second (bps) with the prefix K (kilobit), M (megabit), or G (gigabit). Each Ethernet category (cat) cable supports a different Ethernet standard and thereby determines the bandwidth capacity or maximum throughput.</span></p>
<p lang=""><span>帶寬和吞吐量都以比特每秒（bps）為單位，前綴為K（千比特），M（兆比特）或G（千兆比特）。每條以太網類別（CAT）電纜均支持不同的以太網標準，從而確定帶寬容量或最大吞吐量。</span></p>
<p lang=""><span> The table below shows the bandwidth according to Ethernet type.</span></p>
<p lang=""><span>下表顯示了根據以太網類型的帶寬。</span></p>
<p lang=""><span><img alt="" height="227" src="/images/HW1-1.png" width="509"/></span></p>
<h2>Planning a Basic Network Connection Using 100&amp;1000Base使用100＆1000Base規劃基本的網絡連接</h2>
<p><a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ef90a0001dc00e1634b45d7d907">https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2ef90a0001dc00e1634b45d7d907</a></p>
<h3>Planning a Basic Network Connection Using 100&amp;1000Base使用100＆1000Base規劃基本的網絡連接</h3>
<p id="N10688" lang="">Now that you have a general understanding of networking hardware, application of standards for LANs (local area networks) and WANs (wide area networks), and the limitations of the media used, you should be able to plan adding a network node to an already existing network.</p>
<p lang="">既然您已經對網絡硬件，LAN（局域網）和WAN（廣域網）的標準的應用以及所用媒體的限制有了一般的了解，那麼您應該能夠計劃將網絡節點添加到已經現有網絡。</p>
<p lang="">For example, you could add a new computer to your company’s wired LAN.</p>
<p lang="">例如，您可以將新計算機添加到公司的有線局域網中。</p>
<p lang="">In such situations, the majority of the hardware installation is plug and play (PnP), but you still have to know that the hardware and media chosen are correct, configure software settings for network access, and verify the new hardware will function properly to allow user access to all network resources.</p>
<p lang="">在這種情況下，大多數硬件安裝都是即插即用（PnP），但您仍然必須知道所選的硬件和媒體是正確的，配置用於網絡訪問的軟件設置，並驗證新硬件是否正常運行以允許用戶訪問所有網絡資源。</p>
<p id="N1068B" lang="">Current technology in most small office/home office (SOHO) environments will have auto-sensing networking hardware.</p>
<p lang="">大多數小型辦公室/家庭辦公室（SOHO）環境中的當前技術都將具有自動感應網絡硬件。</p>
<p lang="">There are older switches and routers that still remain in some networks that do not have the ability to run at 100/1000BaseT, so check your network documentation!</p>
<p lang="">有些舊的交換機和路由器仍然保留在某些不能在100 / 1000BaseT上運行的網絡中，因此請查看您的網絡文檔！</p>
<h3>Media媒體</h3>
<div class="section" id="N1068E">
<div class="sectionContain">
<p id="N10695" lang="">Installing a wired connection onto the network means knowing if the NIC (network interface card) of the device can also auto-negotiate throughput based on the cable media used.</p>
<p lang="">在網絡上安裝有線連接意味著要知道設備的NIC（網絡接口卡）是否還可以根據所使用的電纜介質自動協商吞吐量。</p>
<p lang="">Again, new or current technology should be auto-sensing and auto-negotiating (speed, duplex mode and other network parameters).</p>
<p lang="">同樣，新技術或當前技術應該是自動感應和自動協商（速度，雙工模式和其他網絡參數）。</p>
<p lang="">The most important decision for the technician is selecting the correct type of Ethernet cable to connect the device.</p>
<p lang="">對於技術人員而言，最重要的決定是選擇正確的以太網電纜類型來連接設備。</p>
<p lang="">Recall that the cable standards will restrict distance as well as throughput.</p>
<p lang=""><span>回想一下，電纜標準將限制距離以及吞吐量。 </span></p>
<p lang="">A cat 5 cable was standard for 100BaseT but will limit throughput to 100 Mbps so you must use cat 5e or cat 6 if you are trying to achieve 1000BaseT (1 Gbps).</p>
</div>
</div>
<div class="section" id="N1069A">
<div class="sectionContain">Cat 5電纜是100BaseT的標準配置，但將吞吐量限制為100 Mbps，因此，如果要實現1000BaseT（1 Gbps），則必須使用Cat 5e或Cat6。</div>
<h3>Distance距離</h3>
<div class="section" id="N1069A">
<div class="sectionContain">
<p id="N106A1" lang="">Most current SOHO environments will have Ethernet wall jacks internally connecting to the next network device, be it a switch or a hub.</p>
<p lang="">當前大多數SOHO環境將在內部將以太網牆壁插孔連接到下一個網絡設備，無論是交換機還是集線器。</p>
<p lang="">But, if there is not a connection already present, you must remember that all copper-based Ethernet cable is limited to 100 meters.</p>
<p lang="">但是，如果尚不存在連接，則必須記住所有基於銅纜的以太網電纜限制為100米。</p>
<p lang="">Do not run the wire in an area where the cabling can cause a safety hazard, become damaged due to environmental conditions, or suffer from electromagnetic interference (EMI).</p>
<p lang="">請勿在可能會導致安全隱患，因環境條件而損壞電纜或遭受電磁干擾（EMI）的區域中佈線。</p>
</div>
</div>
<div class="section" id="N106A6">
<h3>Verify Connectivity驗證連接性</h3>
<p id="N106AD" lang="">After the machine is connected and powered on (assuming Windows 7 or later), watch the system tray after boot-up to see if there is a wired network icon.</p>
<p lang="">連接機器並打開電源後（假設使用Windows 7或更高版本），啟動後請查看系統托盤，以查看是否有有線網絡圖標。</p>
<p lang="">The standard Windows 7 icons are:</p>
<p>Windows 7的標準圖標是：</p>
<p><img alt="" height="150" src="/images/HW1-2.png" width="569"/></p>
<div class="section" id="N106A6">
<div class="sectionContain">
<p id="N106BB" lang="">Access the “network sharing center” to select the type of network access you need to have and add any devices required for the node (e.g., a printer).</p>
<p lang="">訪問“網絡共享中心”以選擇所需的網絡訪問類型，並添加該節點所需的任何設備（例如打印機）。</p>
<p lang="">Verify access by opening the browser or using a command line tool to verify connectivity and addressing.</p>
</div>
</div>
<div actguid="d87f2f140a0001dc503fc79774f89706" class="asx" inlineparams="inlineClient=%2Fsuperactivity%2Fassessment2%2FInlineAssessmentClient.swf&amp;activityMode=delivery&amp;activityContextGUID=d87f2f140a0001dc503fc79774f89706&amp;userGUID=40923221%40gm.nfu.edu.tw&amp;activityService=%2Fjcourse%2Fa2%2Frest&amp;webContentPath=%2Frepository%2Fwebcontent%2Fd826575d0a0001dc3e9f244fa018c560%2F&amp;logService=%2Flog%2Fserver&amp;">
<div class="activitywrap purpose learnbydoing flash" id="dpch12_lbd06">
<div class="activityhead">通過打開瀏覽器或使用命令行工具來驗證訪問權限，以驗證連接性和地址。</div>
<h2>Differentiating Between Ethernet and TCP and IP區分以太網和TCP和IP-1</h2>
<p><a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2efa0a0001dc4336b4adb87938b6">https://oli.cmu.edu/jcourse/workbook/activity/page?context=d87f2efa0a0001dc4336b4adb87938b6</a></p>
<h3>Differentiating Between Ethernet and TCP&amp;IP區分以太網和TCP＆IP-2</h3>
<p><span>As an A+ certified technician, you will be introduced to the basics of computer networking, which is further covered when learning the CompTIA Net+ standards.</span></p>
<p><span>作為A +認證的技術人員，將向您介紹計算機網絡的基礎知識，在學習CompTIA Net +標準時將進一步介紹這些知識。</span></p>
<p><span> Although CompTIA A+ does not test on the open systems interconnection model (OSI model), it is a theoretical model that is the basis for the way data travels through computer networks.</span></p>
<p><span>儘管CompTIA A +沒有在開放系統互連模型（OSI模型）上進行測試，但它是一種理論模型，是數據在計算機網絡中傳輸的基礎。</span></p>
<p><span> When you click on an icon and connect to the Internet through a browser such as Google Chrome, Mozilla Firefox, or Internet Explorer, a request to connect is sent through a series of steps from the application layer down to the physical layer. </span></p>
<p><span>當您單擊圖標並通過瀏覽器（例如Google Chrome，Mozilla Firefox或Internet Explorer）連接到Internet時，連接請求將通過從應用程序層到物理層的一系列步驟發送。</span></p>
<p><span>All data physically enters and exits a computer node (client, server, or printer) through a network interface card (NIC) based on the type of medium being used (wireless, copper, or fiber-optic).</span></p>
<p><span>根據使用的介質類型（無線，銅纜或光纖），所有數據都通過網絡接口卡（NIC）物理地進入和退出計算機節點（客戶端，服務器或打印機）。</span></p>
<p><span>The data packets are represented and interpreted using the binary number system.</span></p>
<p><span>數據包使用二進制數字系統表示和解釋。</span></p>
<p><span><img alt="" height="433" src="/images/WH1-3.png" width="568"/></span></p>
<h3>Protocols規約</h3>
<div class="section" id="N10699">
<div class="sectionContain">
<p id="N106A0" lang="">In computer networking, a protocol is a set of communication rules by which data communication occurs.</p>
<p lang="">在計算機網絡中，協議是通過其進行數據通信的一組通信規則。</p>
<p lang="">The popularity of Ethernet is based on the standardization of protocols and ability to use the TCP/IP suite to carry data throughout a variety of hardware devices.</p>
</div>
</div>
<div class="section" id="N106A5">
<div class="sectionContain">以太網的普及是基於協議的標準化以及使用TCP / IP套件在各種硬件設備中傳輸數據的能力。</div>
</div>
<p><span>Ethernet乙太網路</span></p>
<p><span>Ethernet is defined by the IEEE 802.3 specification, which sets the standard and interoperability between devices, allowing communication over computer networks. </span></p>
<p><span>以太網由IEEE 802.3規範定義，該規範設置了設備之間的標準和互操作性，從而允許通過計算機網絡進行通信。</span></p>
<p><span>These specifications control how data physically travels between nodes on both the physical layer and the data link layer through media access control (MAC). </span></p>
<p><span>這些規範通過媒體訪問控制（MAC）控制數據在物理層和數據鏈路層上的節點之間的物理傳輸方式。</span></p>
<p><span>The hardware controlled by these specifications include NICs, wiring (i.e., cat 5, 5e, and 6) including the RJ-45 connectors, switches, and hubs.</span></p>
<p><span>這些規範所控制的硬件包括NIC，包括RJ-45連接器，交換機和集線器的佈線（即Cat 5、5e和6）。</span></p>
<h3>TCP&amp;IP</h3>
<p><span>Whereas Ethernet controls the physical data, transmission control protocol and Internet protocol (TCP/IP) is a suite of protocols that operate logically throughout the different layers of the OSI model as well as in the TCP/IP model.</span></p>
<p><span>以太網控制物理數據，而傳輸控制協議和Internet協議（TCP / IP）是一套協議，可以在OSI模型的不同層以及TCP / IP模型中進行邏輯操作。</span></p>
<p><span><img alt="" height="595" src="/images/WH1-4.png" width="529"/></span></p>
<div class="section" id="N106B1">
<div class="sectionContain">
<p id="N106C4" lang="">A good analogy to help understand how Ethernet uses TCP/IP to transport data is to consider the old pneumatic tube systems used by banks.</p>
<p lang="">一個很好的類比可以幫助理解以太網如何使用TCP / IP傳輸數據，是考慮銀行使用的舊式氣動系統。</p>
<p lang="">The tube and the carrier that the deposit envelope is placed in represent Ethernet.</p>
<p lang="">放置存款信封的管子和載體代表以太網。</p>
<p lang="">The envelope and the currency represent a protocol from the TCP/IP suite used throughout different layers (see additional information<span> </span><a href="http://superuser.com/questions/206431/ethernet-vs-tcp-vs-ip" id="_i_3" lang="" target="_blank">here</a>).</p>
</div>
</div>
<div actguid="d87f2f190a0001dc79087ffb3e23f9a4" class="asx" inlineparams="inlineClient=%2Fsuperactivity%2Fassessment2%2FInlineAssessmentClient.swf&amp;activityMode=delivery&amp;activityContextGUID=d87f2f190a0001dc79087ffb3e23f9a4&amp;userGUID=40923221%40gm.nfu.edu.tw&amp;activityService=%2Fjcourse%2Fa2%2Frest&amp;webContentPath=%2Frepository%2Fwebcontent%2Fd826575d0a0001dc3e9f244fa018c560%2F&amp;logService=%2Flog%2Fserver&amp;">
<div class="activitywrap purpose learnbydoing flash" id="dpch12_lbd07">
<div class="activityhead">信封和貨幣表示來自TCP / IP套件的協議，在整個不同層中使用。</div>
<div class="activityhead"></div>
<h1>HW2</h1>
<h2>變數 Variables</h2>
<p><a href="https://books.trinket.io/pfe/02-variables.html">https://books.trinket.io/pfe/02-variables.html</a> </p>
<p>練習 : <a href="https://www.kaggle.com/chanzhirru/variables/edit">https://www.kaggle.com/chanzhirru/variables/edit</a></p>
<br/><br/>Variables, expressions, and statements,Values and types
<p><br/>變量，表達式和語句，值和類型</p>
<p>A<span> </span><em>value</em><span> </span>is one of the basic things a program works with, like a letter or a number. The values we have seen so far are<span> </span><code>1</code>,<span> </span><code>2</code>, and "Hello, World!"</p>
<p>值是程序使用的基本內容之一，例如字母或數字。到目前為止，我們看到的值為1、2和“ Hello，World！”。</p>
<p>These values belong to different<span> </span><em>types</em>:<span> </span><code>2</code><span> </span>is an integer, and "Hello, World!" is a<span> </span><em>string</em>, so called because it contains a "string" of letters. You (and the interpreter) can identify strings because they are enclosed in quotation marks.</p>
<p>這些值屬於不同的類型：2是整數，“ Hello，World！”是字符串，之所以稱為字符串是因為它包含字母的“字符串”。您（和解釋器）可以識別字符串，因為它們用引號引起來。</p>
<p>The<span> </span><code>print</code><span> </span>statement also works for integers. We use the<span> </span><code>python</code><span> </span>command to start the interpreter.</p>
<p>print語句也適用於整數。我們使用python命令啟動解釋器。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">python
&gt;&gt;&gt; print(4)</pre>
<p><span>If you are not sure what type a value has, the interpreter can tell you.</span></p>
<p><span>如果您不確定值的類型，解釋器可以告訴您。</span></p>
<p><span>Not surprisingly, strings belong to the type <code>str</code><span><span> </span>and integers belong to the type<span> </span></span><code>int</code><span>. Less obviously, numbers with a decimal point belong to a type called<span> </span></span><code>float</code><span>, because these numbers are represented in a format called<span> </span></span><em>floating point</em></span></p>
<p><span><em>毫不奇怪，字符串屬於str類型，而整數屬於int類型。不太明顯的是，帶小數點的數字屬於稱為浮點的類型，因為這些數字以稱為浮點的格式表示</em></span></p>
<p>What about values like "17" and "3.2"? They look like numbers, but they are in quotation marks like strings.</p>
<p>那麼“ 17”和“ 3.2”之類的值呢？它們看起來像數字，但用引號引起來，例如字符串。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; type('17')
&gt;&gt;&gt; type('3.2')</pre>
<p>They're strings.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">他們是字符串。</span></pre>
<p>When you type a large integer, you might be tempted to use commas between groups of three digits, as in<span> </span><code>1,000,000</code>. This is not a legal integer in Python, but it is legal:</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW">當您輸入一個大整數時，您可能會想在三位數的組之間使用逗號，例如1,000,000。在Python中這不是合法的整數，但它是合法的：<br/></span></pre>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(1,000,000)</pre>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span>Well, that's not what we expected at all! Python interprets </span><code>1,000,000</code><span><span> </span>as a comma-separated sequence of integers, which it prints with spaces between.</span><br/>好吧，這根本不是我們所期望的！ Python將1,000,000解釋為以逗號分隔的整數序列，並在其之間打印出空格。<br/></span></pre>
<p>This is the first example we have seen of a semantic error: the code runs without producing an error message, but it doesn't do the "right" thing.</p>
<p>這是我們看到的第一個語義錯誤示例：代碼運行時未產生錯誤消息，但沒有做“正確的”事情。</p>
<p>Variables 變數</p>
<p><span>One of the most powerful features of a programming language is the ability to manipulate </span><em>variables</em><span>. A variable is a name that refers to a value.</span></p>
<p><span>編程語言最強大的功能之一就是能夠操縱變量。變量是引用值的名稱。</span></p>
<p><span>An <em>assignment statement</em><span><span> </span>creates new variables and gives them values:</span></span></p>
<p><span><span>賦值語句創建新變量並為其提供值：</span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; message = 'And now for something completely different'
&gt;&gt;&gt; n = 17
&gt;&gt;&gt; pi = 3.1415926535897931</pre>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW"><span>This example makes three assignments. The first assigns a string to a new variable named </span><code>message</code><span>; the second assigns the integer<span> </span></span><code>17</code><span><span> </span>to<span> </span></span><code>n</code><span>; the third assigns the (approximate) value of<span> </span></span><span class="math"><em>π</em></span><span><span> </span>to<span> </span></span><code>pi</code><span>.</span><br/>本示例進行了三個分配。第一個將字符串分配給一個名為message的新變量；第二個將整數17分配給n；第三個將π的（近似）值分配給pi。<br/><span>To display the value of a variable, you can use a print statement:</span><br/>要顯示變量的值，可以使用打印語句：<br/></span></pre>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(n)
17
&gt;&gt;&gt; print(pi)
3.141592653589793</pre>
<p>The type of a variable is the type of the value it refers to.</p>
<p>變量的類型是它所引用的值的類型。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; type(message)
&lt;class 'str'&gt;
&gt;&gt;&gt; type(n)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(pi)
&lt;class 'float'&gt;</pre>
<h2 class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">Conditional execution Boolean expressions 有條件的執行布爾表達式</span></h2>
<p>A<span> </span><em>boolean expression</em><span> </span>is an expression that is either true or false. The following examples use the operator<span> </span><code>==</code>, which compares two operands and produces<span> </span><code>True</code><span> </span>if they are equal and<span> </span><code>False</code><span> </span>otherwise:</p>
<p>布爾表達式是對或錯的表達式。以下示例使用運算符==，該運算符將比較兩個操作數，如果兩個操作數相等，則產生True，否則產生False：</p>
<p><code>True</code><span> </span>and<span> </span><code>False</code><span> </span>are special values that belong to the class<span> </span><code>bool</code>; they are not strings:</p>
<p>True和False是屬於bool類的特殊值；它們不是字符串：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; type(True)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;</pre>
<p>The<span> </span><code>==</code><span> </span>operator is one of the<span> </span><em>comparison operators</em>; the others are:</p>
<p>==運算符是比較運算符之一；其他的是：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">      x != y               # x is not equal to y
      x &gt; y                # x is greater than y
      x &lt; y                # x is less than y
      x &gt;= y               # x is greater than or equal to y
      x &lt;= y               # x is less than or equal to y
      x is y               # x is the same as y
      x is not y           # x is not the same as y</pre>
<p>Although these operations are probably familiar to you, the Python symbols are different from the mathematical symbols for the same operations. A common error is to use a single equal sign (<code>=</code>) instead of a double equal sign (<code>==</code>). Remember that<span> </span><code>=</code><span> </span>is an assignment operator and<span> </span><code>==</code><span> </span>is a comparison operator. There is no such thing as<span> </span><code>=&lt;</code><span> </span>or<span> </span><code>=&gt;</code>.</p>
<p>儘管您可能熟悉這些操作，但是對於相同的操作，Python符號與數學符號不同。一個常見的錯誤是使用單等號（=）而不是雙等號（==）。請記住，=是賦值運算符，而==是比較運算符。沒有==或=&gt;這樣的東西。</p>
<h3>Logical operators 邏輯運算符</h3>
<p>There are three<span> </span><em>logical operators</em>:<span> </span><code>and</code>,<span> </span><code>or</code>, and<span> </span><code>not</code>. The semantics (meaning) of these operators is similar to their meaning in English. For example,</p>
<p>存在三個邏輯運算符：和，或，和不。這些運算符的語義（含義）類似於英語中的含義。例如，</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x &gt; 0 and x &lt; 10

</pre>
<p>is true only if<span> </span><code>x</code><span> </span>is greater than 0<span> </span><em>and</em><span> </span>less than 10.</p>
<p>僅當x大於0且小於10時才為true。</p>
<p><code>n%2 == 0 or n%3 == 0</code><span> </span>is true if<span> </span><em>either</em><span> </span>of the conditions is true, that is, if the number is divisible by 2<span> </span><em>or</em><span> </span>3.</p>
<p>如果兩個條件中的任何一個為真，即數字可以被2或3整除，則n％2 == 0或n％3 == 0為true。</p>
<p>Finally, the<span> </span><code>not</code><span> </span>operator negates a boolean expression, so<span> </span><code>not (x &gt; y)</code><span> </span>is true if<span> </span><code>x &gt; y</code><span> </span>is false; that is, if<span> </span><code>x</code><span> </span>is less than or equal to<span> </span><code>y</code>.</p>
<p>最後，not運算符取反布爾表達式，因此，如果x&gt; y為false，則（x&gt; y）不為true；也就是說，如果x小於或等於y。</p>
<p>Strictly speaking, the operands of the logical operators should be boolean expressions, but Python is not very strict. Any nonzero number is interpreted as "true."</p>
<p>嚴格來說，邏輯運算符的操作數應該是布爾表達式，但是Python並不是很嚴格。任何非零數字都將解釋為“ true”。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; 17 and True
True</pre>
<p>This flexibility can be useful, but there are some subtleties to it that might be confusing. You might want to avoid it until you are sure you know what you are doing.</p>
<p>這種靈活性可能很有用，但其中的一些細微之處可能會造成混淆。您可能要避免使用它，直到您確定自己知道自己在做什麼。</p>
<h3>Conditional execution 有條件的執行</h3>
<p>In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly.<span> </span><em>Conditional statements</em><span> </span>give us this ability. The simplest form is the<span> </span><code>if</code><span> </span>statement:</p>
<p>為了編寫有用的程序，我們幾乎總是需要具有檢查條件並相應地更改程序行為的能力。條件語句使我們具備了這種能力。最簡單的形式是if語句：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if x &gt; 0 :
    print('x is positive')</pre>
<p>The boolean expression after the<span> </span><code>if</code><span> </span>statement is called the<span> </span><em>condition</em>. We end the<span> </span><code>if</code><span> </span>statement with a colon character (:) and the line(s) after the if statement are indented.</p>
<p>if語句之後的布爾表達式稱為條件。我們將if語句以冒號（:)結束，並將if語句後的行縮進。</p>
<p><img alt="If Logic" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSI3IDYgMjIwIDE1MCIgd2lkdGg9IjIyMHB0IiBoZWlnaHQ9IjE1MHB0IiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxtZXRhZGF0YT4gUHJvZHVjZWQgYnkgT21uaUdyYWZmbGUgNi41IDxkYzpkYXRlPjIwMTYtMDQtMDggMTA6NDg6MTkgKzAwMDA8L2RjOmRhdGU+PC9tZXRhZGF0YT48ZGVmcz48ZmlsdGVyIGlkPSJTaGFkb3ciIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PGZlR2F1c3NpYW5CbHVyIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJibHVyIiBzdGREZXZpYXRpb249IjEuMzA4Ii8+PGZlT2Zmc2V0IGluPSJibHVyIiByZXN1bHQ9Im9mZnNldCIgZHg9IjAiIGR5PSIyIi8+PGZlRmxvb2QgZmxvb2QtY29sb3I9ImJsYWNrIiBmbG9vZC1vcGFjaXR5PSIuNSIgcmVzdWx0PSJmbG9vZCIvPjxmZUNvbXBvc2l0ZSBpbj0iZmxvb2QiIGluMj0ib2Zmc2V0IiBvcGVyYXRvcj0iaW4iLz48L2ZpbHRlcj48Zm9udC1mYWNlIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTAiIHVuaXRzLXBlci1lbT0iMTAwMCIgdW5kZXJsaW5lLXBvc2l0aW9uPSItNzUuNjgzNTk0IiB1bmRlcmxpbmUtdGhpY2tuZXNzPSI0OS4zMTY0MDYiIHNsb3BlPSIwIiB4LWhlaWdodD0iNTIyLjk0OTIyIiBjYXAtaGVpZ2h0PSI3MTcuMjg1MTYiIGFzY2VudD0iNzcwLjAxOTUzIiBkZXNjZW50PSItMjI5Ljk4MDQ3IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iSGVsdmV0aWNhIi8+PC9mb250LWZhY2Utc3JjPjwvZm9udC1mYWNlPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBvdmVyZmxvdz0idmlzaWJsZSIgbWFya2VyVW5pdHM9InN0cm9rZVdpZHRoIiBpZD0iRmlsbGVkQXJyb3dfTWFya2VyIiB2aWV3Qm94PSItMSAtMyA3IDYiIG1hcmtlcldpZHRoPSI3IiBtYXJrZXJIZWlnaHQ9IjYiIGNvbG9yPSJibGFjayI+PGc+PHBhdGggZD0iTSA0LjggMCBMIDAgLTEuOCBMIDAgMS44IFoiIGZpbGw9ImN1cnJlbnRDb2xvciIgc3Ryb2tlPSJjdXJyZW50Q29sb3IiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L21hcmtlcj48Zm9udC1mYWNlIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxMyIgcGFub3NlLTE9IjIgMCA1IDMgMCAwIDAgMiAwIDQiIHVuaXRzLXBlci1lbT0iMTAwMCIgdW5kZXJsaW5lLXBvc2l0aW9uPSItMTAwIiB1bmRlcmxpbmUtdGhpY2tuZXNzPSI1MCIgc2xvcGU9IjAiIHgtaGVpZ2h0PSI1MTciIGNhcC1oZWlnaHQ9IjcxNCIgYXNjZW50PSI5NTEuOTk1ODUiIGRlc2NlbnQ9Ii0yMTIuOTk3NDQiIGZvbnQtd2VpZ2h0PSI1MDAiPjxmb250LWZhY2Utc3JjPjxmb250LWZhY2UtbmFtZSBuYW1lPSJIZWx2ZXRpY2FOZXVlIi8+PC9mb250LWZhY2Utc3JjPjwvZm9udC1mYWNlPjwvZGVmcz48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1vcGFjaXR5PSIxIiBzdHJva2UtZGFzaGFycmF5PSJub25lIiBmaWxsPSJub25lIiBmaWxsLW9wYWNpdHk9IjEiPjx0aXRsZT5DYW52YXMgMTwvdGl0bGU+PHJlY3QgZmlsbD0id2hpdGUiIHdpZHRoPSIzNDciIGhlaWdodD0iNjEzIi8+PGc+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxnPjx4bDp1c2UgeGw6aHJlZj0iI2lkM19HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx4bDp1c2UgeGw6aHJlZj0iI2lkMTlfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48L2c+PGcgaWQ9ImlkM19HcmFwaGljIj48cGF0aCBkPSJNIDU0IDM2IEwgOTkgNTQgTCA1NCA3MiBMIDkgNTQgWiIgZmlsbD0id2hpdGUiLz48cGF0aCBkPSJNIDU0IDM2IEwgOTkgNTQgTCA1NCA3MiBMIDkgNTQgWiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi4xNSA0Ny42NCkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTcuNzcwOTk2IiB5PSIxMCIgdGV4dExlbmd0aD0iMjEuOTU4MDA4Ij54ICZndDsgMDwvdHNwYW4+PC90ZXh0PjwvZz48ZyBpZD0iaWQxOV9HcmFwaGljIj48cmVjdCB4PSIxMDgiIHk9IjcyIiB3aWR0aD0iMTE3IiBoZWlnaHQ9IjM2IiBmaWxsPSJ3aGl0ZSIvPjxyZWN0IHg9IjEwOCIgeT0iNzIiIHdpZHRoPSIxMTciIGhlaWdodD0iMzYiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTEzIDg0KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEwIiBmb250LXdlaWdodD0iNTAwIiB4PSIxMC45OTAyMzQ0IiB5PSIxMCIgdGV4dExlbmd0aD0iODUuMDE5NTMiPnByaW50KOKAmHggaXMgcG9zdGl0aXZl4oCZKTwvdHNwYW4+PC90ZXh0PjwvZz48cGF0aCBkPSJNIDk5IDU0IEwgMTE0LjkgNTQgTCAxNjYuNSA1NCBMIDE2Ni41IDcyIEwgMTY2LjUgNTYuMSBMIDE2Ni41IDU5LjEiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48cGF0aCBkPSJNIDU0IDkgTCA1NCAxNC41NSBMIDU0IDIwLjEgTCA1NCAyMy4xIiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTSA1NCA3MiBMIDU0IDg3LjkgTCA1NCAxMjAuNDUgTCA1NCAxNDAuMSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0gMTY2LjUgMTA4IEwgMTY2LjUgMTIzLjkgTCAxMTguMiAxMjMuOTUgTCA2OS45IDEyNCBMIDY2LjkgMTI0IiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTE1LjUgMzUuNSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iNTAwIiB4PSIuMjY5IiB5PSIxMiIgdGV4dExlbmd0aD0iOC40MjQiPlk8L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjcuMjUiIHk9IjEyIiB0ZXh0TGVuZ3RoPSIxMy40ODEiPmVzPC90c3Bhbj48L3RleHQ+PC9nPjwvZz48L3N2Zz4K"/></p>
<p>If the logical condition is true, then the indented statement gets executed. If the logical condition is false, the indented statement is skipped.</p>
<p>如果邏輯條件為真，則執行縮進語句。如果邏輯條件為假，則縮進語句將被跳過。</p>
<p><code>if</code><span> </span>statements have the same structure as function definitions or<span> </span><code>for</code><span> </span>loops<a class="footnoteRef" href="https://books.trinket.io/pfe/03-conditional.html#fn1" id="fnref1"><sup>1</sup></a>. The statement consists of a header line that ends with the colon character (:) followed by an indented block. Statements like this are called<span> </span><em>compound statements</em><span> </span>because they stretch across more than one line.</p>
<p>if語句的結構與函數定義或forloops1相同。該語句由標題行組成，該標題行以冒號（:)結尾，後跟一個縮進的塊。這樣的語句稱為複合語句，因為它們跨越多行。</p>
<p>There is no limit on the number of statements that can appear in the body, but there must be at least one. Occasionally, it is useful to have a body with no statements (usually as a place holder for code you haven't written yet). In that case, you can use the<span> </span><code>pass</code><span> </span>statement, which does nothing.</p>
<p>正文中可以顯示的語句數量沒有限制，但必須至少有一個。有時，不帶任何語句的主體很有用（通常用作您尚未編寫的代碼的佔位符）。在這種情況下，您可以使用pass語句，該語句不執行任何操作。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if x &lt; 0 :
    pass          # need to handle negative values!</pre>
<p>If you enter an<span> </span><code>if</code><span> </span>statement in the Python interpreter, the prompt will change from three chevrons to three dots to indicate you are in the middle of a block of statements, as shown below:</p>
<p>如果在Python解釋器中輸入if語句，則提示將從三個V形符號變為三個點，以指示您位於語句塊的中間，如下所示：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; x = 3
&gt;&gt;&gt; if x &lt; 10:
...    print('Small')
...
Small
&gt;&gt;&gt;</pre>
<h3>Alternative execution 替代執行</h3>
<p>A second form of the<span> </span><code>if</code><span> </span>statement is<span> </span><em>alternative execution</em>, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:</p>
<p>if語句的第二種形式是替代執行，其中有兩種可能性，條件決定執行哪一種。語法如下所示：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if x%2 == 0 :
    print('x is even')
else :
    print('x is odd')</pre>
<p>If the remainder when<span> </span><code>x</code><span> </span>is divided by 2 is 0, then we know that<span> </span><code>x</code><span> </span>is even, and the program displays a message to that effect. If the condition is false, the second set of statements is executed.</p>
<p>如果將x除以2時的餘數為0，則我們知道x為偶數，並且程序將顯示一條消息表示該結果。如果條件為假，則執行第二組語句。</p>
<p><img alt="If-Then-Else Logic" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIxNiA2IDM0NiAxNTgiIHdpZHRoPSIzNDZwdCIgaGVpZ2h0PSIxNThwdCIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj48bWV0YWRhdGE+IFByb2R1Y2VkIGJ5IE9tbmlHcmFmZmxlIDYuNSA8ZGM6ZGF0ZT4yMDE2LTA0LTA4IDEwOjQ4OjQwICswMDAwPC9kYzpkYXRlPjwvbWV0YWRhdGE+PGRlZnM+PGZpbHRlciBpZD0iU2hhZG93IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiPjxmZUdhdXNzaWFuQmx1ciBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0iYmx1ciIgc3RkRGV2aWF0aW9uPSIxLjMwOCIvPjxmZU9mZnNldCBpbj0iYmx1ciIgcmVzdWx0PSJvZmZzZXQiIGR4PSIwIiBkeT0iMiIvPjxmZUZsb29kIGZsb29kLWNvbG9yPSJibGFjayIgZmxvb2Qtb3BhY2l0eT0iLjUiIHJlc3VsdD0iZmxvb2QiLz48ZmVDb21wb3NpdGUgaW49ImZsb29kIiBpbjI9Im9mZnNldCIgb3BlcmF0b3I9ImluIi8+PC9maWx0ZXI+PGZvbnQtZmFjZSBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEwIiB1bml0cy1wZXItZW09IjEwMDAiIHVuZGVybGluZS1wb3NpdGlvbj0iLTc1LjY4MzU5NCIgdW5kZXJsaW5lLXRoaWNrbmVzcz0iNDkuMzE2NDA2IiBzbG9wZT0iMCIgeC1oZWlnaHQ9IjUyMi45NDkyMiIgY2FwLWhlaWdodD0iNzE3LjI4NTE2IiBhc2NlbnQ9Ijc3MC4wMTk1MyIgZGVzY2VudD0iLTIyOS45ODA0NyIgZm9udC13ZWlnaHQ9IjUwMCI+PGZvbnQtZmFjZS1zcmM+PGZvbnQtZmFjZS1uYW1lIG5hbWU9IkhlbHZldGljYSIvPjwvZm9udC1mYWNlLXNyYz48L2ZvbnQtZmFjZT48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiIG1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgaWQ9IkZpbGxlZEFycm93X01hcmtlciIgdmlld0JveD0iLTEgLTMgNyA2IiBtYXJrZXJXaWR0aD0iNyIgbWFya2VySGVpZ2h0PSI2IiBjb2xvcj0iYmxhY2siPjxnPjxwYXRoIGQ9Ik0gNC44IDAgTCAwIC0xLjggTCAwIDEuOCBaIiBmaWxsPSJjdXJyZW50Q29sb3IiIHN0cm9rZT0iY3VycmVudENvbG9yIiBzdHJva2Utd2lkdGg9IjEiLz48L2c+PC9tYXJrZXI+PGZvbnQtZmFjZSBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTMiIHBhbm9zZS0xPSIyIDAgNSAzIDAgMCAwIDIgMCA0IiB1bml0cy1wZXItZW09IjEwMDAiIHVuZGVybGluZS1wb3NpdGlvbj0iLTEwMCIgdW5kZXJsaW5lLXRoaWNrbmVzcz0iNTAiIHNsb3BlPSIwIiB4LWhlaWdodD0iNTE3IiBjYXAtaGVpZ2h0PSI3MTQiIGFzY2VudD0iOTUxLjk5NTg1IiBkZXNjZW50PSItMjEyLjk5NzQ0IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iSGVsdmV0aWNhTmV1ZSIvPjwvZm9udC1mYWNlLXNyYz48L2ZvbnQtZmFjZT48L2RlZnM+PGcgc3Ryb2tlPSJub25lIiBzdHJva2Utb3BhY2l0eT0iMSIgc3Ryb2tlLWRhc2hhcnJheT0ibm9uZSIgZmlsbD0ibm9uZSIgZmlsbC1vcGFjaXR5PSIxIj48dGl0bGU+Q2FudmFzIDE8L3RpdGxlPjxyZWN0IGZpbGw9IndoaXRlIiB3aWR0aD0iNDcxIiBoZWlnaHQ9IjYxMyIvPjxnPjx0aXRsZT5MYXllciAxPC90aXRsZT48Zz48eGw6dXNlIHhsOmhyZWY9IiNpZDNfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48eGw6dXNlIHhsOmhyZWY9IiNpZDE5X0dyYXBoaWMiIGZpbHRlcj0idXJsKCNTaGFkb3cpIi8+PHhsOnVzZSB4bDpocmVmPSIjaWQyN19HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjwvZz48ZyBpZD0iaWQzX0dyYXBoaWMiPjxwYXRoIGQ9Ik0gMTg5IDM2IEwgMjM0IDU0IEwgMTg5IDcyIEwgMTQ0IDU0IFoiIGZpbGw9IndoaXRlIi8+PHBhdGggZD0iTSAxODkgMzYgTCAyMzQgNTQgTCAxODkgNzIgTCAxNDQgNTQgWiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjEuMTUgNDcuNjQpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTAiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjcuNjI0NTExNyIgeT0iMTAiIHRleHRMZW5ndGg9IjQyLjI1MDk3NyI+eCUyID09IDA8L3RzcGFuPjwvdGV4dD48L2c+PGcgaWQ9ImlkMTlfR3JhcGhpYyI+PHJlY3QgeD0iMjQzIiB5PSI3MiIgd2lkdGg9IjExNyIgaGVpZ2h0PSIzNiIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSIyNDMiIHk9IjcyIiB3aWR0aD0iMTE3IiBoZWlnaHQ9IjM2IiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDI0OCA4NCkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTguNDkwMjM0IiB5PSIxMCIgdGV4dExlbmd0aD0iNzAuMDE5NTMiPnByaW50KOKAmHggaXMgZXZlbuKAmSk8L3RzcGFuPjwvdGV4dD48L2c+PHBhdGggZD0iTSAyMzQgNTQgTCAyNDkuOSA1NCBMIDMwMS41IDU0IEwgMzAxLjUgNzIgTCAzMDEuNSA1Ni4xIEwgMzAxLjUgNTkuMSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0gMTg5IDkgTCAxODkgMTQuNTUgTCAxODkgMjAuMSBMIDE4OSAyMy4xIiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTSAxODkgMTM1IEwgMTg5IDE0OCBMIDE4OSAxNDguMSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0gMzAxLjUgMTA4IEwgMzAxLjUgMTIzLjkgTCAzMDEuNSAxMjkuNDUgTCAyNDUuMjUgMTI5LjQ1IEwgMjAwLjY0NTA2IDEyOS40NSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1MC41IDM1LjUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iLjI2OSIgeT0iMTIiIHRleHRMZW5ndGg9IjguNDI0Ij5ZPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iNTAwIiB4PSI3LjI1IiB5PSIxMiIgdGV4dExlbmd0aD0iMTMuNDgxIj5lczwvdHNwYW4+PC90ZXh0PjxnIGlkPSJpZDI3X0dyYXBoaWMiPjxyZWN0IHg9IjE4IiB5PSI3NCIgd2lkdGg9IjExNyIgaGVpZ2h0PSIzNiIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSIxOCIgeT0iNzQiIHdpZHRoPSIxMTciIGhlaWdodD0iMzYiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjMgODYpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTAiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjIwLjk5MDIzNCIgeT0iMTAiIHRleHRMZW5ndGg9IjY1LjAxOTUzIj5wcmludCjigJh4IGlzIG9kZOKAmSk8L3RzcGFuPjwvdGV4dD48L2c+PHBhdGggZD0iTSAxNDQgNTQgTCAxMjguMSA1NCBMIDc2LjUgNTQgTCA3Ni41IDc0IEwgNzYuNSA1OC4xIEwgNzYuNSA2MS4xIiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTSA3Ni41IDExMCBMIDc2LjUgMTI1LjkgTCA3Ni41IDEzMC40NSBMIDEzMi43NSAxMzAuNDUgTCAxNzYuOTI5MDYgMTMwLjQ1IiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTE1IDMyLjUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iLjA3NiIgeT0iMTIiIHRleHRMZW5ndGg9IjE2Ljg0OCI+Tm88L3RzcGFuPjwvdGV4dD48L2c+PC9nPjwvc3ZnPgo="/></p>
<p>Since the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called<span> </span><em>branches</em>, because they are branches in the flow of execution.</p>
<p>由於條件必須為true或false，因此將精確執行其中一種選擇。替代方案稱為分支，因為它們是執行流程中的分支。</p>
<h3>Chained conditionals 鏈接條件</h3>
<p>Sometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a<span> </span><em>chained conditional</em>:</p>
<p>有時有兩種以上的可能性，而我們需要兩個以上的分支。表示這樣的計算的一種方法是鏈接條件：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if x &lt; y:
    print('x is less than y')
elif x &gt; y:
    print('x is greater than y')
else:
    print('x and y are equal')</pre>
<p><code>elif</code><span> </span>is an abbreviation of "else if." Again, exactly one branch will be executed.</p>
<p>elif是“ else if”的縮寫。同樣，將只執行一個分支。</p>
<p><img alt="If-Then-ElseIf Logic" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSI3IDYgMjQ2IDIzMSIgd2lkdGg9IjI0NnB0IiBoZWlnaHQ9IjIzMXB0IiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxtZXRhZGF0YT4gUHJvZHVjZWQgYnkgT21uaUdyYWZmbGUgNi41IDxkYzpkYXRlPjIwMTYtMDQtMDggMTA6NDk6NTMgKzAwMDA8L2RjOmRhdGU+PC9tZXRhZGF0YT48ZGVmcz48ZmlsdGVyIGlkPSJTaGFkb3ciIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PGZlR2F1c3NpYW5CbHVyIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJibHVyIiBzdGREZXZpYXRpb249IjEuMzA4Ii8+PGZlT2Zmc2V0IGluPSJibHVyIiByZXN1bHQ9Im9mZnNldCIgZHg9IjAiIGR5PSIyIi8+PGZlRmxvb2QgZmxvb2QtY29sb3I9ImJsYWNrIiBmbG9vZC1vcGFjaXR5PSIuNSIgcmVzdWx0PSJmbG9vZCIvPjxmZUNvbXBvc2l0ZSBpbj0iZmxvb2QiIGluMj0ib2Zmc2V0IiBvcGVyYXRvcj0iaW4iLz48L2ZpbHRlcj48Zm9udC1mYWNlIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTAiIHVuaXRzLXBlci1lbT0iMTAwMCIgdW5kZXJsaW5lLXBvc2l0aW9uPSItNzUuNjgzNTk0IiB1bmRlcmxpbmUtdGhpY2tuZXNzPSI0OS4zMTY0MDYiIHNsb3BlPSIwIiB4LWhlaWdodD0iNTIyLjk0OTIyIiBjYXAtaGVpZ2h0PSI3MTcuMjg1MTYiIGFzY2VudD0iNzcwLjAxOTUzIiBkZXNjZW50PSItMjI5Ljk4MDQ3IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iSGVsdmV0aWNhIi8+PC9mb250LWZhY2Utc3JjPjwvZm9udC1mYWNlPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBvdmVyZmxvdz0idmlzaWJsZSIgbWFya2VyVW5pdHM9InN0cm9rZVdpZHRoIiBpZD0iRmlsbGVkQXJyb3dfTWFya2VyIiB2aWV3Qm94PSItMSAtMyA3IDYiIG1hcmtlcldpZHRoPSI3IiBtYXJrZXJIZWlnaHQ9IjYiIGNvbG9yPSJibGFjayI+PGc+PHBhdGggZD0iTSA0LjggMCBMIDAgLTEuOCBMIDAgMS44IFoiIGZpbGw9ImN1cnJlbnRDb2xvciIgc3Ryb2tlPSJjdXJyZW50Q29sb3IiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L21hcmtlcj48Zm9udC1mYWNlIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxMyIgcGFub3NlLTE9IjIgMCA1IDMgMCAwIDAgMiAwIDQiIHVuaXRzLXBlci1lbT0iMTAwMCIgdW5kZXJsaW5lLXBvc2l0aW9uPSItMTAwIiB1bmRlcmxpbmUtdGhpY2tuZXNzPSI1MCIgc2xvcGU9IjAiIHgtaGVpZ2h0PSI1MTciIGNhcC1oZWlnaHQ9IjcxNCIgYXNjZW50PSI5NTEuOTk1ODUiIGRlc2NlbnQ9Ii0yMTIuOTk3NDQiIGZvbnQtd2VpZ2h0PSI1MDAiPjxmb250LWZhY2Utc3JjPjxmb250LWZhY2UtbmFtZSBuYW1lPSJIZWx2ZXRpY2FOZXVlIi8+PC9mb250LWZhY2Utc3JjPjwvZm9udC1mYWNlPjwvZGVmcz48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1vcGFjaXR5PSIxIiBzdHJva2UtZGFzaGFycmF5PSJub25lIiBmaWxsPSJub25lIiBmaWxsLW9wYWNpdHk9IjEiPjx0aXRsZT5DYW52YXMgMTwvdGl0bGU+PHJlY3QgZmlsbD0id2hpdGUiIHdpZHRoPSIzNDciIGhlaWdodD0iNjEzIi8+PGc+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxnPjx4bDp1c2UgeGw6aHJlZj0iI2lkM19HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx4bDp1c2UgeGw6aHJlZj0iI2lkMTlfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48eGw6dXNlIHhsOmhyZWY9IiNpZDI3X0dyYXBoaWMiIGZpbHRlcj0idXJsKCNTaGFkb3cpIi8+PHhsOnVzZSB4bDpocmVmPSIjaWQyOF9HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx4bDp1c2UgeGw6aHJlZj0iI2lkMzRfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48L2c+PGcgaWQ9ImlkM19HcmFwaGljIj48cGF0aCBkPSJNIDU0IDM2IEwgOTkgNTQgTCA1NCA3MiBMIDkgNTQgWiIgZmlsbD0id2hpdGUiLz48cGF0aCBkPSJNIDU0IDM2IEwgOTkgNTQgTCA1NCA3MiBMIDkgNTQgWiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi4xNSA0Ny42NCkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTguMDUxNzU4IiB5PSIxMCIgdGV4dExlbmd0aD0iMjEuMzk2NDg0Ij54ICZsdDsgeTwvdHNwYW4+PC90ZXh0PjwvZz48ZyBpZD0iaWQxOV9HcmFwaGljIj48cmVjdCB4PSIxNDQiIHk9IjQwIiB3aWR0aD0iNzkiIGhlaWdodD0iMjciIGZpbGw9IndoaXRlIi8+PHJlY3QgeD0iMTQ0IiB5PSI0MCIgd2lkdGg9Ijc5IiBoZWlnaHQ9IjI3IiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDE0OSA0Ny41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEwIiBmb250LXdlaWdodD0iNTAwIiB4PSIxMC4zMzAwNzgiIHk9IjEwIiB0ZXh0TGVuZ3RoPSI0OC4zMzk4NDQiPnByaW50KOKAmGxlc3PigJkpPC90c3Bhbj48L3RleHQ+PC9nPjxwYXRoIGQ9Ik0gOTkgNTQgTCAxMTQuOSA1NCBMIDEyMS41IDUzLjc1IEwgMTI4LjEgNTMuNSBMIDEzMS4xIDUzLjUiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48cGF0aCBkPSJNIDU0IDkgTCA1NCAxNC41NSBMIDU0IDIwLjEgTCA1NCAyMy4xIiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTSAyNTAgNTYgTCAyNTAgMjA3LjMzMzMzIEwgNTQgMjA3LjMzMzMzIEwgNjkuOSAyMDcuMzMzMzMgTCA2Ni45IDIwNy4zMzMzMyIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwNC41IDM1LjUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iLjI2OSIgeT0iMTIiIHRleHRMZW5ndGg9IjguNDI0Ij5ZPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iNTAwIiB4PSI3LjI1IiB5PSIxMiIgdGV4dExlbmd0aD0iMTMuNDgxIj5lczwvdHNwYW4+PC90ZXh0PjxnIGlkPSJpZDI3X0dyYXBoaWMiPjxwYXRoIGQ9Ik0gNTQgOTkgTCA5OSAxMTcgTCA1NCAxMzUgTCA5IDExNyBaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGQ9Ik0gNTQgOTkgTCA5OSAxMTcgTCA1NCAxMzUgTCA5IDExNyBaIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjE1IDExMC42NCkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTguMDUxNzU4IiB5PSIxMCIgdGV4dExlbmd0aD0iMjEuMzk2NDg0Ij54ICZndDsgeTwvdHNwYW4+PC90ZXh0PjwvZz48ZyBpZD0iaWQyOF9HcmFwaGljIj48cmVjdCB4PSIxNDQiIHk9IjEwMyIgd2lkdGg9Ijc5IiBoZWlnaHQ9IjI3IiBmaWxsPSJ3aGl0ZSIvPjxyZWN0IHg9IjE0NCIgeT0iMTAzIiB3aWR0aD0iNzkiIGhlaWdodD0iMjciIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQ5IDExMC41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEwIiBmb250LXdlaWdodD0iNTAwIiB4PSIxLjgwNDY4NzUiIHk9IjEwIiB0ZXh0TGVuZ3RoPSI1OS40Njc3NzMiPnByaW50ICjigJhncmVhdGVyPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iNjEuNjQzNTU1IiB5PSIxMCIgdGV4dExlbmd0aD0iNS41NTE3NTc4Ij7igJkpPC90c3Bhbj48L3RleHQ+PC9nPjxwYXRoIGQ9Ik0gOTkgMTE3IEwgMTE0LjkgMTE3IEwgMTIxLjUgMTE2Ljc1IEwgMTI4LjEgMTE2LjUgTCAxMzEuMSAxMTYuNSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0gNTQgNzIgTCA1NCA3Ny41NSBMIDU0IDgzLjEgTCA1NCA4Ni4xIiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA0LjUgOTguNSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iNTAwIiB4PSIuMjY5IiB5PSIxMiIgdGV4dExlbmd0aD0iOC40MjQiPlk8L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjcuMjUiIHk9IjEyIiB0ZXh0TGVuZ3RoPSIxMy40ODEiPmVzPC90c3Bhbj48L3RleHQ+PHBhdGggZD0iTSA1NCAxMzUgTCA1NCAxNDguNSBMIDU0IDE0OS4xIiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PGcgaWQ9ImlkMzRfR3JhcGhpYyI+PHJlY3QgeD0iMTgiIHk9IjE2MiIgd2lkdGg9IjcyIiBoZWlnaHQ9IjI3IiBmaWxsPSJ3aGl0ZSIvPjxyZWN0IHg9IjE4IiB5PSIxNjIiIHdpZHRoPSI3MiIgaGVpZ2h0PSIyNyIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMyAxNjkuNSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMy40ODc3OTMiIHk9IjEwIiB0ZXh0TGVuZ3RoPSI1NS4wMjQ0MTQiPnByaW50KOKAmGVxdWFs4oCZKTwvdHNwYW4+PC90ZXh0PjwvZz48cGF0aCBkPSJNIDU0IDE4OSBMIDU0IDIxMS41IEwgNTQgMjIxLjEiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMjIzIiB5MT0iNTMuNSIgeDI9IjIzNy4xMDk3IiB5Mj0iNTMuNSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0gMjIzIDExNyBMIDIzNi41IDExNy4yNSBMIDIzNy4xMDIyMSAxMTcuMjYxMTUiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48L2c+PC9nPjwvc3ZnPgo="/></p>
<p>There is no limit on the number of<span> </span><code>elif</code><span> </span>statements. If there is an<span> </span><code>else</code><span> </span>clause, it has to be at the end, but there doesn't have to be one.</p>
<p>elif語句的數量沒有限制。如果存在else子句，則必須將其結尾，但不必一定要包含另一個子句。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if choice == 'a':
    print('Bad guess')
elif choice == 'b':
    print('Good guess')
elif choice == 'c':
    print('Close, but not correct')</pre>
<p>Each condition is checked in order. If the first is false, the next is checked, and so on. If one of them is true, the corresponding branch executes, and the statement ends. Even if more than one condition is true, only the first true branch executes.</p>
<p>依次檢查每個條件。如果第一個為假，則檢查下一個，依此類推。如果其中之一為真，則執行相應的分支，然後語句結束。即使有多個條件為真，也僅執行第一個真分支。</p>
<h3>Nested conditionals 嵌套條件</h3>
<p>One conditional can also be nested within another. We could have written the three-branch example like this:</p>
<p>一個條件也可以嵌套在另一個條件中。我們可以這樣編寫三個分支的示例：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if x == y:
    print('x and y are equal')
else:
    if x &lt; y:
        print('x is less than y')
    else:
        print('x is greater than y')</pre>
<p>The outer conditional contains two branches. The first branch contains a simple statement. The second branch contains another<span> </span><code>if</code><span> </span>statement, which has two branches of its own. Those two branches are both simple statements, although they could have been conditional statements as well.</p>
<p>外部條件包含兩個分支。第一個分支包含一個簡單的語句。第二個分支包含另一個if語句，它具有自己的兩個分支。這兩個分支都是簡單的語句，儘管它們也可能是條件語句。</p>
<p><img alt="Nested If Statements" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIxNiA2IDUyNiAyNDgiIHdpZHRoPSI1MjZwdCIgaGVpZ2h0PSIyNDhwdCIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj48bWV0YWRhdGE+IFByb2R1Y2VkIGJ5IE9tbmlHcmFmZmxlIDYuNSA8ZGM6ZGF0ZT4yMDE2LTA0LTA4IDEwOjQ3OjMzICswMDAwPC9kYzpkYXRlPjwvbWV0YWRhdGE+PGRlZnM+PGZpbHRlciBpZD0iU2hhZG93IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiPjxmZUdhdXNzaWFuQmx1ciBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0iYmx1ciIgc3RkRGV2aWF0aW9uPSIxLjMwOCIvPjxmZU9mZnNldCBpbj0iYmx1ciIgcmVzdWx0PSJvZmZzZXQiIGR4PSIwIiBkeT0iMiIvPjxmZUZsb29kIGZsb29kLWNvbG9yPSJibGFjayIgZmxvb2Qtb3BhY2l0eT0iLjUiIHJlc3VsdD0iZmxvb2QiLz48ZmVDb21wb3NpdGUgaW49ImZsb29kIiBpbjI9Im9mZnNldCIgb3BlcmF0b3I9ImluIi8+PC9maWx0ZXI+PGZvbnQtZmFjZSBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEwIiB1bml0cy1wZXItZW09IjEwMDAiIHVuZGVybGluZS1wb3NpdGlvbj0iLTc1LjY4MzU5NCIgdW5kZXJsaW5lLXRoaWNrbmVzcz0iNDkuMzE2NDA2IiBzbG9wZT0iMCIgeC1oZWlnaHQ9IjUyMi45NDkyMiIgY2FwLWhlaWdodD0iNzE3LjI4NTE2IiBhc2NlbnQ9Ijc3MC4wMTk1MyIgZGVzY2VudD0iLTIyOS45ODA0NyIgZm9udC13ZWlnaHQ9IjUwMCI+PGZvbnQtZmFjZS1zcmM+PGZvbnQtZmFjZS1uYW1lIG5hbWU9IkhlbHZldGljYSIvPjwvZm9udC1mYWNlLXNyYz48L2ZvbnQtZmFjZT48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiIG1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgaWQ9IkZpbGxlZEFycm93X01hcmtlciIgdmlld0JveD0iLTEgLTMgNyA2IiBtYXJrZXJXaWR0aD0iNyIgbWFya2VySGVpZ2h0PSI2IiBjb2xvcj0iYmxhY2siPjxnPjxwYXRoIGQ9Ik0gNC44IDAgTCAwIC0xLjggTCAwIDEuOCBaIiBmaWxsPSJjdXJyZW50Q29sb3IiIHN0cm9rZT0iY3VycmVudENvbG9yIiBzdHJva2Utd2lkdGg9IjEiLz48L2c+PC9tYXJrZXI+PGZvbnQtZmFjZSBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTMiIHBhbm9zZS0xPSIyIDAgNSAzIDAgMCAwIDIgMCA0IiB1bml0cy1wZXItZW09IjEwMDAiIHVuZGVybGluZS1wb3NpdGlvbj0iLTEwMCIgdW5kZXJsaW5lLXRoaWNrbmVzcz0iNTAiIHNsb3BlPSIwIiB4LWhlaWdodD0iNTE3IiBjYXAtaGVpZ2h0PSI3MTQiIGFzY2VudD0iOTUxLjk5NTg1IiBkZXNjZW50PSItMjEyLjk5NzQ0IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iSGVsdmV0aWNhTmV1ZSIvPjwvZm9udC1mYWNlLXNyYz48L2ZvbnQtZmFjZT48L2RlZnM+PGcgc3Ryb2tlPSJub25lIiBzdHJva2Utb3BhY2l0eT0iMSIgc3Ryb2tlLWRhc2hhcnJheT0ibm9uZSIgZmlsbD0ibm9uZSIgZmlsbC1vcGFjaXR5PSIxIj48dGl0bGU+Q2FudmFzIDE8L3RpdGxlPjxyZWN0IGZpbGw9IndoaXRlIiB3aWR0aD0iNzAzIiBoZWlnaHQ9IjU5OCIvPjxnPjx0aXRsZT5MYXllciAxPC90aXRsZT48Zz48eGw6dXNlIHhsOmhyZWY9IiNpZDNfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48eGw6dXNlIHhsOmhyZWY9IiNpZDI3X0dyYXBoaWMiIGZpbHRlcj0idXJsKCNTaGFkb3cpIi8+PHhsOnVzZSB4bDpocmVmPSIjaWQ0MF9HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx4bDp1c2UgeGw6aHJlZj0iI2lkNDFfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48eGw6dXNlIHhsOmhyZWY9IiNpZDQ3X0dyYXBoaWMiIGZpbHRlcj0idXJsKCNTaGFkb3cpIi8+PC9nPjxnIGlkPSJpZDNfR3JhcGhpYyI+PHBhdGggZD0iTSAxODkgMzYgTCAyMzQgNTQgTCAxODkgNzIgTCAxNDQgNTQgWiIgZmlsbD0id2hpdGUiLz48cGF0aCBkPSJNIDE4OSAzNiBMIDIzNCA1NCBMIDE4OSA3MiBMIDE0NCA1NCBaIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MS4xNSA0Ny42NCkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTUuMTMxODM2IiB5PSIxMCIgdGV4dExlbmd0aD0iMjcuMjM2MzI4Ij54ID09IHk8L3RzcGFuPjwvdGV4dD48L2c+PHBhdGggZD0iTSAxODkgOSBMIDE4OSAxNC41NSBMIDE4OSAyMC4xIEwgMTg5IDIzLjEiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48cGF0aCBkPSJNIDE4OSAyMTYgTCAxODkgMjMzLjUgTCAxODkgMjM4LjEiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNTIuNSAzNS41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9Ii4wNzYiIHk9IjEyIiB0ZXh0TGVuZ3RoPSIxNi44NDgiPk5vPC90c3Bhbj48L3RleHQ+PGcgaWQ9ImlkMjdfR3JhcGhpYyI+PHJlY3QgeD0iMTgiIHk9IjEwMSIgd2lkdGg9IjExNyIgaGVpZ2h0PSIzNiIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSIxOCIgeT0iMTAxIiB3aWR0aD0iMTE3IiBoZWlnaHQ9IjM2IiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDIzIDExMykiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMjUuOTg3NzkzIiB5PSIxMCIgdGV4dExlbmd0aD0iNTUuMDI0NDE0Ij5wcmludCjigJhlcXVhbOKAmSk8L3RzcGFuPjwvdGV4dD48L2c+PHBhdGggZD0iTSAxNDQgNTQgTCAxMjguMSA1NCBMIDc2LjUgNTQgTCA3Ni41IDEwMSBMIDc2LjUgODUuMSBMIDc2LjUgODguMSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0gNzYuNSAxMzcgTCA3Ni41IDE1Mi45IEwgNzYuNSAyMTYgTCAxODkgMjE2IEwgMTczLjEgMjE2IEwgMTc2LjEgMjE2IiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTEzIDMyLjUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iLjI2OSIgeT0iMTIiIHRleHRMZW5ndGg9IjguNDI0Ij5ZPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iNTAwIiB4PSI3LjI1IiB5PSIxMiIgdGV4dExlbmd0aD0iMTMuNDgxIj5lczwvdHNwYW4+PC90ZXh0PjxnIGlkPSJpZDQwX0dyYXBoaWMiPjxwYXRoIGQ9Ik0gMzY5IDgxIEwgNDE0IDk5IEwgMzY5IDExNyBMIDMyNCA5OSBaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGQ9Ik0gMzY5IDgxIEwgNDE0IDk5IEwgMzY5IDExNyBMIDMyNCA5OSBaIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDM0MS4xNSA5Mi42NCkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTguMDUxNzU4IiB5PSIxMCIgdGV4dExlbmd0aD0iMjEuMzk2NDg0Ij54ICZsdDsgeTwvdHNwYW4+PC90ZXh0PjwvZz48ZyBpZD0iaWQ0MV9HcmFwaGljIj48cmVjdCB4PSI0MjMiIHk9IjExNyIgd2lkdGg9IjExNyIgaGVpZ2h0PSIzNiIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSI0MjMiIHk9IjExNyIgd2lkdGg9IjExNyIgaGVpZ2h0PSIzNiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MjggMTI5KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEwIiBmb250LXdlaWdodD0iNTAwIiB4PSIyMi43NDgwNDciIHk9IjEwIiB0ZXh0TGVuZ3RoPSI1NS41ODEwNTUiPnByaW504oCZ4oCYZ3JlYXRlcjwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTAiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9Ijc4LjcwMDE5NSIgeT0iMTAiIHRleHRMZW5ndGg9IjUuNTUxNzU3OCI+4oCZKTwvdHNwYW4+PC90ZXh0PjwvZz48cGF0aCBkPSJNIDQxNCA5OSBMIDQyOS45IDk5IEwgNDgxLjUgOTkgTCA0ODEuNSAxMTcgTCA0ODEuNSAxMDEuMSBMIDQ4MS41IDEwNC4xIiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTSAyMzQgNTQgTCAyNDkuOSA1NCBMIDM2OSA1NCBMIDM2OSA4MSBMIDM2OSA2NS4xIEwgMzY5IDY4LjEiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48cGF0aCBkPSJNIDM2OSAyMTYgTCAyNzkgMjE2IEwgMjAxLjkgMjE2IiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTSA0ODEuNSAxNTMgTCA0ODEuNSAxNjguOSBMIDQ4MS41IDE3NC40NSBMIDQyNS4yNSAxNzQuNDUgTCAzODAuNjQ1MDYgMTc0LjQ1IiBtYXJrZXItZW5kPSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDMyLjUgODAuNSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iNTAwIiB4PSIuMDc2IiB5PSIxMiIgdGV4dExlbmd0aD0iMTYuODQ4Ij5ObzwvdHNwYW4+PC90ZXh0PjxnIGlkPSJpZDQ3X0dyYXBoaWMiPjxyZWN0IHg9IjE5OCIgeT0iMTE5IiB3aWR0aD0iMTE3IiBoZWlnaHQ9IjM2IiBmaWxsPSJ3aGl0ZSIvPjxyZWN0IHg9IjE5OCIgeT0iMTE5IiB3aWR0aD0iMTE3IiBoZWlnaHQ9IjM2IiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMyAxMzEpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTAiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjI5LjMzMDA3OCIgeT0iMTAiIHRleHRMZW5ndGg9IjQ4LjMzOTg0NCI+cHJpbnQo4oCYbGVzc+KAmSk8L3RzcGFuPjwvdGV4dD48L2c+PHBhdGggZD0iTSAzMjQgOTkgTCAzMDguMSA5OSBMIDI1Ni41IDk5IEwgMjU2LjUgMTE5IEwgMjU2LjUgMTAzLjEgTCAyNTYuNSAxMDYuMSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0gMjU2LjUgMTU1IEwgMjU2LjUgMTcwLjkgTCAyNTYuNSAxNzUuNDUgTCAzMTIuNzUgMTc1LjQ1IEwgMzU2LjkyOTA2IDE3NS40NSIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDI5MyA3Ny41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9Ii4yNjkiIHk9IjEyIiB0ZXh0TGVuZ3RoPSI4LjQyNCI+WTwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iNy4yNSIgeT0iMTIiIHRleHRMZW5ndGg9IjEzLjQ4MSI+ZXM8L3RzcGFuPjwvdGV4dD48cGF0aCBkPSJNIDM2OCAxODEgTCAzNjggMTk4LjUgTCAzNjggMjAzLjEiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48L2c+PC9nPjwvc3ZnPgo="/></p>
<p>Although the indentation of the statements makes the structure apparent,<span> </span><em>nested conditionals</em><span> </span>become difficult to read very quickly. In general, it is a good idea to avoid them when you can.</p>
<p>儘管語句的縮進使結構顯而易見，但是嵌套條件變得很難快速讀取。通常，最好在可能的情況下避免使用它們。</p>
<p>Logical operators often provide a way to simplify nested conditional statements. For example, we can rewrite the following code using a single conditional:</p>
<p>邏輯運算符通常提供一種簡化嵌套條件語句的方法。例如，我們可以使用一個條件重寫以下代碼：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if 0 &lt; x:
    if x &lt; 10:
        print('x is a positive single-digit number.')</pre>
<p>The<span> </span><code>print</code><span> </span>statement is executed only if we make it past both conditionals, so we can get the same effect with the<span> </span><code>and</code><span> </span>operator:</p>
<p>僅當我們通過兩個條件時才執行print語句，因此使用and運算符可以獲得相同的效果：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if 0 &lt; x and x &lt; 10:
    print('x is a positive single-digit number.')</pre>
<h3>Catching exceptions using try and except 使用try和except捕獲異常</h3>
<p>Earlier we saw a code segment where we used the<span> </span><code>input</code><span> </span>and<span> </span><code>int</code><span> </span>functions to read and parse an integer number entered by the user. We also saw how treacherous doing this could be:</p>
<p>之前我們看到了一個代碼段，在該段中，我們使用了輸入和int函數來讀取和解析用戶輸入的整數。我們還看到這樣做很危險：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; prompt = "What...is the airspeed velocity of an unladen swallow?\n"
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
&gt;&gt;&gt; int(speed)
ValueError: invalid literal for int() with base 10:
&gt;&gt;&gt;</pre>
<p>When we are executing these statements in the Python interpreter, we get a new prompt from the interpreter, think "oops", and move on to our next statement.</p>
<p>當我們在Python解釋器中執行這些語句時，我們會從解釋器得到一個新提示，認為是“ oops”，然後繼續執行下一條語句。</p>
<p>However if you place this code in a Python script and this error occurs, your script immediately stops in its tracks with a traceback. It does not execute the following statement.</p>
<p>但是，如果將此代碼放置在Python腳本中並且發生此錯誤，則您的腳本會立即停止運行並進行追溯。它不執行以下語句。</p>
<p>Here is a sample program to convert a Fahrenheit temperature to a Celsius temperature:</p>
<p>這是將華氏溫度轉換為攝氏溫度的示例程序：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">inp = input('Enter Fahrenheit Temperature: ')
fahr = float(inp)
cel = (fahr - 32.0) * 5.0 / 9.0
print(cel)</pre>
<p>If we execute this code and give it invalid input, it simply fails with an unfriendly error message:</p>
<p>如果我們執行此代碼並提供無效輸入，則它只會失敗並顯示不友好的錯誤消息：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">python fahren.py
Enter Fahrenheit Temperature:72
22.22222222222222</pre>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">python fahren.py
Enter Fahrenheit Temperature:fred
Traceback (most recent call last):
  File "fahren.py", line 2, in &lt;module&gt;
    fahr = float(inp)
ValueError: could not convert string to float: 'fred'</pre>
<p>There is a conditional execution structure built into Python to handle these types of expected and unexpected errors called "try / except". The idea of<span> </span><code>try</code><span> </span>and<span> </span><code>except</code><span> </span>is that you know that some sequence of instruction(s) may have a problem and you want to add some statements to be executed if an error occurs. These extra statements (the except block) are ignored if there is no error.</p>
<p>Python內置了一個條件執行結構來處理這些類型的預期錯誤和意外錯誤，稱為“ try / except”。 try andexcept的想法是，您知道某些指令序列可能會出現問題，並且如果發生錯誤，則希望添加一些要執行的語句。如果沒有錯誤，將忽略這些額外的語句（except塊）。</p>
<p>You can think of the<span> </span><code>try</code><span> </span>and<span> </span><code>except</code><span> </span>feature in Python as an "insurance policy" on a sequence of statements.</p>
<p>您可以將Python中的try andexcept功能視為一系列語句上的“保險政策”。</p>
<p>We can rewrite our temperature converter as follows:</p>
<p>我們可以重寫溫度轉換器，如下所示：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">inp = input('Enter Fahrenheit Temperature:')
try:
    fahr = float(inp)
    cel = (fahr - 32.0) * 5.0 / 9.0
    print(cel)
except:
    print('Please enter a number')</pre>
<p>Python starts by executing the sequence of statements in the<span> </span><code>try</code><span> </span>block. If all goes well, it skips the<span> </span><code>except</code><span> </span>block and proceeds. If an exception occurs in the<span> </span><code>try</code><span> </span>block, Python jumps out of the<span> </span><code>try</code><span> </span>block and executes the sequence of statements in the<span> </span><code>except</code><span> </span>block.</p>
<p>Python首先執行try塊中的語句序列。如果一切順利，它將跳過except塊並繼續。如果try塊中發生異常，Python將從try塊中跳出並在except塊中執行語句序列。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python fahren2.py
Enter Fahrenheit Temperature:72
22.22222222222222</pre>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python fahren2.py
Enter Fahrenheit Temperature:fred
Please enter a number</pre>
<p>Handling an exception with a<span> </span><code>try</code><span> </span>statement is called<span> </span><em>catching</em><span> </span>an exception. In this example, the<span> </span><code>except</code><span> </span>clause prints an error message. In general, catching an exception gives you a chance to fix the problem, or try again, or at least end the program gracefully.</p>
<p>使用try語句處理異常稱為捕獲異常。在此示例中，except子句顯示錯誤消息。通常，捕獲異常使您有機會解決問題，重試或至少正常地結束程序。</p>
<h3>Short-circuit evaluation of logical expressions 邏輯表達式的短路評估</h3>
<p>When Python is processing a logical expression such as<span> </span><code>x &gt;= 2 and (x/y) &gt; 2</code>, it evaluates the expression from left to right. Because of the definition of<span> </span><code>and</code>, if<span> </span><code>x</code><span> </span>is less than 2, the expression<span> </span><code>x &gt;= 2</code><span> </span>is<span> </span><code>False</code><span> </span>and so the whole expression is<span> </span><code>False</code><span> </span>regardless of whether<span> </span><code>(x/y) &gt; 2</code><span> </span>evaluates to<span> </span><code>True</code><span> </span>or<span> </span><code>False</code>.</p>
<p>當Python處理諸如x&gt; = 2和（x / y）&gt; 2之類的邏輯表達式時，它將從左到右評估該表達式。由於and的定義，如果x小於2，則表達式x&gt; = 2為False，因此整個表達式為False，而不管（x / y）&gt; 2是True還是False。</p>
<p>When Python detects that there is nothing to be gained by evaluating the rest of a logical expression, it stops its evaluation and does not do the computations in the rest of the logical expression. When the evaluation of a logical expression stops because the overall value is already known, it is called<span> </span><em>short-circuiting</em><span> </span>the evaluation.</p>
<p>當Python檢測到無法通過評估邏輯表達式的其餘部分獲得任何好處時，它將停止其評估，而不會在邏輯表達式的其餘部分中進行計算。當邏輯表達式的求值由於總值已知而停止時，稱為短路求值。</p>
<p>While this may seem like a fine point, the short-circuit behavior leads to a clever technique called the<span> </span><em>guardian pattern</em>. Consider the following code sequence in the Python interpreter:</p>
<p>儘管這似乎是個好主意，但短路行為導致了一種稱為“保護模式”的巧妙技術。考慮一下Python解釋器中的以下代碼序列：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; x = 6
&gt;&gt;&gt; y = 2
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2
True
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2
False
&gt;&gt;&gt; x = 6
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: division by zero</pre>
<p>The third calculation failed because Python was evaluating<span> </span><code>(x/y)</code><span> </span>and<span> </span><code>y</code><span> </span>was zero, which causes a runtime error. But the second example did<span> </span><em>not</em><span> </span>fail because the first part of the expression<span> </span><code>x &gt;= 2</code><span> </span>evaluated to<span> </span><code>False</code><span> </span>so the<span> </span><code>(x/y)</code><span> </span>was not ever executed due to the<span> </span><em>short-circuit</em><span> </span>rule and there was no error.</p>
<p>第三次計算失敗，因為Python正在評估（x / y）並且y為零，這會導致運行時錯誤。但是第二個示例並沒有失敗，因為表達式x&gt; = 2的第一部分評估為False，因此由於短路規則從未執行過（x / y），並且沒有錯誤。</p>
<p>We can construct the logical expression to strategically place a<span> </span><em>guard</em><span> </span>evaluation just before the evaluation that might cause an error as follows:</p>
<p>我們可以構造邏輯表達式，以策略性地將防護評估放在可能導致錯誤的評估之前，如下所示：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and y != 0 and (x/y) &gt; 2
False
&gt;&gt;&gt; x = 6
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and y != 0 and (x/y) &gt; 2
False
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2 and y != 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: division by zero</pre>
<p>In the first logical expression,<span> </span><code>x &gt;= 2</code><span> </span>is<span> </span><code>False</code><span> </span>so the evaluation stops at the<span> </span><code>and</code>. In the second logical expression,<span> </span><code>x &gt;= 2</code><span> </span>is<span> </span><code>True</code><span> </span>but<span> </span><code>y != 0</code><span> </span>is<span> </span><code>False</code><span> </span>so we never reach<span> </span><code>(x/y)</code>.</p>
<p>在第一個邏輯表達式中，x&gt; = 2為False，因此求值在and處停止。在第二個邏輯表達式中，x&gt; = 2為True，但是y！= 0為False，因此我們永遠都無法達到（x / y）。</p>
<p>In the third logical expression, the<span> </span><code>y != 0</code><span> </span>is<span> </span><em>after</em><span> </span>the<span> </span><code>(x/y)</code><span> </span>calculation so the expression fails with an error.</p>
<p>在第三個邏輯表達式中，y！= 0在（x / y）計算之後，因此該表達式失敗並出現錯誤。</p>
<p>In the second expression, we say that<span> </span><code>y != 0</code><span> </span>acts as a<span> </span><em>guard</em><span> </span>to insure that we only execute<span> </span><code>(x/y)</code><span> </span>if<span> </span><code>y</code><span> </span>is non-zero.</p>
<p>在第二個表達式中，我們說y！= 0充當保護，以確保僅在y為非零時才執行（x / y）。</p>
<h3>Debugging 調試</h3>
<p>The traceback Python displays when an error occurs contains a lot of information, but it can be overwhelming. The most useful parts are usually:</p>
<p>發生錯誤時，Python回溯顯示包含很多信息，但可能不勝枚舉。最有用的部分通常是：</p>
<ul>
<li>
<p>What kind of error it was, and 那是什麼錯誤，以及</p>
</li>
<li><span>Where it occurred. 發生的地方。</span><span></span></li>
</ul>
<p>Syntax errors are usually easy to find, but there are a few gotchas. Whitespace errors can be tricky because spaces and tabs are invisible and we are used to ignoring them.</p>
<p>語法錯誤通常很容易找到，但是有一些陷阱。空格錯誤可能很棘手，因為空格和製表符是不可見的，我們習慣於忽略它們。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; x = 5
&gt;&gt;&gt;  y = 6
  File "&lt;stdin&gt;", line 1
    y = 6
    ^
IndentationError: unexpected indent</pre>
<p>In this example, the problem is that the second line is indented by one space. But the error message points to<span> </span><code>y</code>, which is misleading. In general, error messages indicate where the problem was discovered, but the actual error might be earlier in the code, sometimes on a previous line.</p>
<p>在此示例中，問題是第二行縮進了一個空格。但是錯誤消息指向y，這會引起誤解。通常，錯誤消息指示發現問題的位置，但是實際錯誤可能在代碼中更早，有時在前一行。</p>
<p>In general, error messages tell you where the problem was discovered, but that is often not where it was caused.</p>
<p>通常，錯誤消息會告訴您問題的出處，但通常不是問題的出處。</p>
<p>Glossary 詞彙表</p>
<dl>
<dt>body</dt>
<dd>複合語句中的語句序列。</dd>
</dl>
<dl>
<dt>boolean expression</dt>
<dd>一個值為True或False的表達式。</dd>
</dl>
<dl>
<dt>branch</dt>
<dd>條件語句中的另一種語句序列之一。</dd>
</dl>
<dl>
<dt>chained conditional</dt>
<dd>具有一系列替代分支的條件語句。</dd>
</dl>
<dl>
<dt>comparison operator</dt>
<dd>
<p>比較其操作數的運算符之一：==，！=，&gt;，&lt;，&gt; =和&lt;=。.</p>
</dd>
<dt>conditional statement</dt>
<dd>根據某些條件控制執行流程的語句。</dd>
</dl>
<dl>
<dt>condition</dt>
<dd>條件語句中的布爾表達式，用於確定執行哪個分支。</dd>
</dl>
<dl>
<dt>compound statement</dt>
<dd>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">由標題和主體組成的語句。標頭以冒號（:)結尾。主體相對於標題縮進。</span></pre>
</dd>
</dl>
<dl>
<dt>guardian pattern</dt>
<dd>我們在這裡構造帶有其他比較的邏輯表達式以利用短路行為。</dd>
</dl>
<dl>
<dt>logical operator</dt>
<dd>
<p>結合佈爾表達式的運算符之一：and，or，and not。</p>
</dd>
<dt>nested conditional</dt>
<dd>在另一個條件語句的一個分支中出現的條件語句。</dd>
</dl>
<dl>
<dt>traceback</dt>
<dd>發生異常時打印的正在執行的功能列表。</dd>
</dl>
<dl>
<dt>short circuit</dt>
<dd>當Python在評估邏輯表達式的過程中停止運行時，由於Python知道了表達式的最終值而無需評估其餘表達式，因此停止了評估。</dd>
</dl>
<h2>Iteration Updating variables 迭代 更新變量</h2>
<p>A common pattern in assignment statements is an assignment statement that updates a variable, where the new value of the variable depends on the old.</p>
<p>賦值語句中的常見模式是更新變量的賦值語句，其中變量的新值取決於舊值。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = x + 1</pre>
<p>This means "get the current value of<span> </span><code>x</code>, add 1, and then update<span> </span><code>x</code><span> </span>with the new value."</p>
<p>這意味著“獲取x的當前值，加1，然後用新值更新x”。</p>
<p>If you try to update a variable that doesn't exist, you get an error, because Python evaluates the right side before it assigns a value to<span> </span><code>x</code>:</p>
<p>如果您嘗試更新不存在的變量，則會收到錯誤消息，因為Python在向x賦值之前先評估右邊：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; x = x + 1
</pre>
<p>Before you can update a variable, you have to initialize it, usually with a simple assignment:</p>
<p>在更新變量之前，必須先對其進行初始化，通常使用簡單的賦值即可：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; x = 0
&gt;&gt;&gt; x = x + 1</pre>
<p>Updating a variable by adding 1 is called an<span> </span><em>increment</em>; subtracting 1 is called a<span> </span><em>decrement</em>.</p>
<p>通過加1來更新變量稱為增量；減1稱為減量。</p>
<h3>The while statement while語句</h3>
<p>Computers are often used to automate repetitive tasks. Repeating identical or similar tasks without making errors is something that computers do well and people do poorly. Because iteration is so common, Python provides several language features to make it easier.</p>
<p>計算機通常用於自動化重複性任務。重複相同或相似的任務而不會出錯，這是計算機做得很好而人們做得不好的事情。因為迭代是如此普遍，所以Python提供了多種語言功能來簡化它。</p>
<p>One form of iteration in Python is the<span> </span><code>while</code><span> </span>statement. Here is a simple program that counts down from five and then says "Blastoff!".</p>
<p>Python的一種迭代形式是while語句。這是一個簡單的程序，從5開始倒數，然後說“ Blastoff！”。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">n = 5
while n &gt; 0:
    print(n)
    n = n - 1
print('Blastoff!')</pre>
<p>You can almost read the<span> </span><code>while</code><span> </span>statement as if it were English. It means, "While<span> </span><code>n</code><span> </span>is greater than 0, display the value of<span> </span><code>n</code><span> </span>and then reduce the value of<span> </span><code>n</code><span> </span>by 1. When you get to 0, exit the<span> </span><code>while</code><span> </span>statement and display the word<span> </span><code>Blastoff!</code>"</p>
<p>您幾乎可以閱讀while語句，就好像它是英語一樣。這意味著，“當n大於0時，顯示n的值，然後將n的值減小1。當您達到0時，退出while語句並顯示單詞Blastoff！”</p>
<p>More formally, here is the flow of execution for a<span> </span><code>while</code><span> </span>statement:</p>
<p>更正式地說，這是while語句的執行流程：</p>
<ol>
<li>
<p>Evaluate the condition, yielding<span> </span><code>True</code><span> </span>or<span> </span><code>False.</code></p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">計算條件，得出True或False。</span></pre>
</li>
<li>
<p>If the condition is false, exit the<span> </span><code>while</code><span> </span>statement and continue execution at the next statement.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">如果條件為假，則退出while語句並在下一條語句處繼續執行。</span></pre>
</li>
</ol>
<p style="display: inline !important;">If the condition is true, execute the body and then go back to step 1.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="zh-TW">如果條件為真，則執行主體，然後返回到步驟1。</span></pre>
<p>This type of flow is called a <em>loop</em> because the third step loops back around to the top. We call each time we execute the body of the loop an <em>iteration</em>. For the above loop, we would say, "It had five iterations", which means that the body of the loop was executed five times.</p>
<p>這種類型的流程稱為循環，因為第三步循環回到頂部。每次執行循環主體時，我們都會調用一次迭代。對於上面的循環，我們會說“它有五次迭代”，這意味著循環的主體執行了五次。</p>
<p>The body of the loop should change the value of one or more variables so that eventually the condition becomes false and the loop terminates. We call the variable that changes each time the loop executes and controls when the loop finishes the<span> </span><em>iteration variable</em>. If there is no iteration variable, the loop will repeat forever, resulting in an<span> </span><em>infinite loop</em>.</p>
<p>循環的主體應更改一個或多個變量的值，以便最終條件變為假並終止循環。我們調用每次循環執行時都會更改的變量，並控制循環何時完成迭代變量。如果沒有迭代變量，則循環將永遠重複，從而導致無限循環。</p>
<h3>Infinite loops 無限循環</h3>
<p>An endless source of amusement for programmers is the observation that the directions on shampoo, "Lather, rinse, repeat," are an infinite loop because there is no<span> </span><em>iteration variable</em><span> </span>telling you how many times to execute the loop.</p>
<p>對於程序員來說，無休止的娛樂來源是觀察到洗髮水上的指示“泡沫，沖洗，重複”是一個無限循環，因為沒有迭代變量告訴您執行循環多少次。對於程序員來說，無休止的娛樂來源是觀察到洗髮水上的指示“泡沫，沖洗，重複”是一個無限循環，因為沒有迭代變量告訴您執行循環多少次。</p>
<p>In the case of<span> </span><code>countdown</code>, we can prove that the loop terminates because we know that the value of<span> </span><code>n</code><span> </span>is finite, and we can see that the value of<span> </span><code>n</code><span> </span>gets smaller each time through the loop, so eventually we have to get to 0. Other times a loop is obviously infinite because it has no iteration variable at all.</p>
<p>In the case of<span> </span><code>countdown</code>, we can prove that the loop terminates because we know that the value of<span> </span><code>n</code><span> </span>is finite, and we can see that the value of<span> </span><code>n</code><span> </span>gets smaller each time through the loop, so eventually we have to get to 0. Other times a loop is obviously infinite because it has no iteration variable at all.</p>
<p>在倒計時的情況下，我們可以證明循環終止，因為我們知道n的值是有限的，並且可以看到每次循環時n的值都會變小，因此最終我們必須達到0。其他時候，循環顯然是無限的，因為它根本沒有迭代變量。在倒計時的情況下，我們可以證明循環終止，因為我們知道n的值是有限的，並且可以看到每次循環時n的值都會變小，因此最終我們必須達到0。其他時候，循環顯然是無限的，因為它根本沒有迭代變量。</p>
<h3>Infinite loops and break 無限循環與突破</h3>
<p>Sometimes you don't know it's time to end a loop until you get half way through the body. In that case you can write an infinite loop on purpose and then use the<span> </span><code>break</code><span> </span>statement to jump out of the loop.</p>
<p>有時，您不知道是時候結束循環了，直到您半途而廢。在這種情況下，您可以故意編寫一個無限循環，然後使用break語句跳出循環。</p>
<p>This loop is obviously an<span> </span><em>infinite loop</em><span> </span>because the logical expression on the<span> </span><code>while</code><span> </span>statement is simply the logical constant<span> </span><code>True</code>:</p>
<p>該循環顯然是一個無限循環，因為while語句上的邏輯表達式只是邏輯常量True：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">n = 10
while True:
    print(n, end=' ')
    n = n - 1
print('Done!')</pre>
<p>If you make the mistake and run this code, you will learn quickly how to stop a runaway Python process on your system or find where the power-off button is on your computer. This program will run forever or until your battery runs out because the logical expression at the top of the loop is always true by virtue of the fact that the expression is the constant value<span> </span><code>True</code>.</p>
<p>如果輸入錯誤並運行此代碼，您將快速學習如何停止系統上失控的Python進程或查找計算機上的電源關閉按鈕的位置。該程序將永遠運行，或者直到電池耗盡，因為循環頂部的邏輯表達式始終為true，這是因為表達式為常數值True。</p>
<p>While this is a dysfunctional infinite loop, we can still use this pattern to build useful loops as long as we carefully add code to the body of the loop to explicitly exit the loop using<span> </span><code>break</code><span> </span>when we have reached the exit condition.</p>
<p>儘管這是一個功能失常的無限循環，但只要我們小心地將代碼添加到循環主體中，以在達到退出條件時使用break顯式退出循環，我們仍然可以使用此模式來構建有用的循環。</p>
<p>For example, suppose you want to take input from the user until they type<span> </span><code>done</code>. You could write:</p>
<p>例如，假設您要在用戶輸入“完成”之前接受用戶的輸入。您可以這樣寫：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">while True:
    line = input('&gt; ')
    if line == 'done':
        break
    print(line)
print('Done!')</pre>
<p>The loop condition is<span> </span><code>True</code>, which is always true, so the loop runs repeatedly until it hits the break statement.</p>
<p>循環條件為True，始終為true，因此循環重複運行，直到命中break語句為止。</p>
<p>Each time through, it prompts the user with an angle bracket. If the user types<span> </span><code>done</code>, the<span> </span><code>break</code><span> </span>statement exits the loop. Otherwise the program echoes whatever the user types and goes back to the top of the loop. Here's a sample run:</p>
<p>每次通過時，都會用尖括號提示用戶。如果用戶鍵入完成，則break語句退出循環。否則，程序將回顯任何用戶鍵入的內容，並返回到循環的頂部。這是一個示例運行：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt; hello there
hello there
&gt; finished
finished
&gt; done
Done!</pre>
<p>This way of writing<span> </span><code>while</code><span> </span>loops is common because you can check the condition anywhere in the loop (not just at the top) and you can express the stop condition affirmatively ("stop when this happens") rather than negatively ("keep going until that happens.").</p>
<p>這種寫while循環的方式很常見，因為您可以在循環中的任何位置（不僅在頂部）檢查條件，而且可以肯定地表示停止條件（“發生這種情況時停止”），而不要否定地表示（繼續進行直到發生。”）。</p>
<h3>Finishing iterations with continue 用continue完成迭代</h3>
<p>Sometimes you are in an iteration of a loop and want to finish the current iteration and immediately jump to the next iteration. In that case you can use the<span> </span><code>continue</code><span> </span>statement to skip to the next iteration without finishing the body of the loop for the current iteration.</p>
<p>有時您處於循環迭代中，想要完成當前迭代並立即跳至下一個迭代。在這種情況下，您可以使用continue語句跳到下一個迭代，而無需完成當前迭代的循環主體。</p>
<p>Here is an example of a loop that copies its input until the user types "done", but treats lines that start with the hash character as lines not to be printed (kind of like Python comments).</p>
<p>這是一個循環示例，該示例複製其輸入，直到用戶鍵入“ done”為止，但是將以哈希字符開頭的行視為不打印的行（類似於Python註釋）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">while True:
    line = input('&gt; ')
    if line[0] == '#':
        continue
    if line == 'done':
        break
    print(line)
print('Done!')</pre>
<p>Here is a sample run of this new program with<span> </span><code>continue</code><span> </span>added.</p>
<p>這是此新程序的示例運行，並添加了continue。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt; hello there
hello there
&gt; # don't print this
&gt; print this!
print this!
&gt; done
Done!</pre>
<p>All the lines are printed except the one that starts with the hash sign because when the<span> </span><code>continue</code><span> </span>is executed, it ends the current iteration and jumps back to the<span> </span><code>while</code><span> </span>statement to start the next iteration, thus skipping the<span> </span><code>print</code><span> </span>statement.</p>
<p>除了以井號開頭的行以外，所有行均被打印，因為執行繼續時，它將結束當前迭代並跳回到while語句以開始下一個迭代，從而跳過print語句。</p>
<h3>Definite loops using for 定環使用for</h3>
<p>Sometimes we want to loop through a<span> </span><em>set</em><span> </span>of things such as a list of words, the lines in a file, or a list of numbers. When we have a list of things to loop through, we can construct a<span> </span><em>definite</em><span> </span>loop using a<span> </span><code>for</code><span> </span>statement. We call the<span> </span><code>while</code><span> </span>statement an<span> </span><em>indefinite</em><span> </span>loop because it simply loops until some condition becomes<span> </span><code>False</code>, whereas the<span> </span><code>for</code><span> </span>loop is looping through a known set of items so it runs through as many iterations as there are items in the set.</p>
<p>有時我們想要遍歷一組事物，例如單詞列表，文件中的行或數字列表。當我們有一系列要循環的事情時，我們可以使用for語句構造一個確定的循環。我們將while語句稱為不確定循環，因為它只是循環直到某些條件變為False為止，而for循環正在遍歷一組已知項，因此它要進行的迭代次數與該組中存在項的次數相同。</p>
<p>The syntax of a<span> </span><code>for</code><span> </span>loop is similar to the<span> </span><code>while</code><span> </span>loop in that there is a<span> </span><code>for</code><span> </span>statement and a loop body:</p>
<p>for循環的語法與while循環相似，因為其中包含for語句和循環主體：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">friends = ['Joseph', 'Glenn', 'Sally']
for friend in friends:
    print('Happy New Year:', friend)
print('Done!')</pre>
<p>In Python terms, the variable<span> </span><code>friends</code><span> </span>is a list<a class="footnoteRef" href="https://books.trinket.io/pfe/05-iterations.html#fn1" id="fnref1"><sup>1</sup></a><span> </span>of three strings and the<span> </span><code>for</code><span> </span>loop goes through the list and executes the body once for each of the three strings in the list resulting in this output:</p>
<p>用Python術語來說，變量friends是一個由三個字符串組成的list1，並且for循環遍歷該列表，並對列表中的三個字符串中的每個字符串執行一次主體，從而得到以下輸出：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">Happy New Year: Joseph
Happy New Year: Glenn
Happy New Year: Sally
Done!</pre>
<p>Translating this<span> </span><code>for</code><span> </span>loop to English is not as direct as the<span> </span><code>while</code>, but if you think of friends as a<span> </span><em>set</em>, it goes like this: "Run the statements in the body of the for loop once for each friend<span> </span><em>in</em><span> </span>the set named friends."</p>
<p>將此for循環翻譯成英語並不像一陣子那樣直接，但是如果您將Friends視為一個集合，它會像這樣：“在for循環的主體中，對命名為friends的集合中的每個朋友運行一次語句。 ”</p>
<p>Looking at the<span> </span><code>for</code><span> </span>loop,<span> </span><em>for</em><span> </span>and<span> </span><em>in</em><span> </span>are reserved Python keywords, and<span> </span><code>friend</code><span> </span>and<span> </span><code>friends</code><span> </span>are variables.</p>
<p>查看for循環，for和in是保留的Python關鍵字，friend和friends是變量。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">for friend in friends:
    print('Happy New Year:', friend)</pre>
<p>In particular,<span> </span><code>friend</code><span> </span>is the<span> </span><em>iteration variable</em><span> </span>for the for loop. The variable<span> </span><code>friend</code><span> </span>changes for each iteration of the loop and controls when the<span> </span><code>for</code><span> </span>loop completes. The<span> </span><em>iteration variable</em><span> </span>steps successively through the three strings stored in the<span> </span><code>friends</code><span> </span>variable.</p>
<p>特別是，friend是for循環的迭代變量。變量friend對於循環的每次迭代都會更改，並控制for循環何時完成。迭代變量依次瀏覽存儲在friends變量中的三個字符串。</p>
<h3>Loop patterns 循環模式</h3>
<p>Often we use a<span> </span><code>for</code><span> </span>or<span> </span><code>while</code><span> </span>loop to go through a list of items or the contents of a file and we are looking for something such as the largest or smallest value of the data we scan through.</p>
<p>通常，我們使用for或while循環遍歷項目列表或文件內容，然後尋找諸如掃描數據的最大值或最小值之類的東西。</p>
<p>These loops are generally constructed by:</p>
<p>這些循環通常通過以下方式構造：</p>
<ul>
<li>
<p>Initializing one or more variables before the loop starts</p>
在循環開始之前初始化一個或多個變量</li>
<li>
<p>Performing some computation on each item in the loop body, possibly changing the variables in the body of the loop</p>
在循環主體中的每個項目上執行一些計算，可能會更改循環主體中的變量</li>
<li>
<p>Looking at the resulting variables when the loop completes</p>
在循環完成時查看結果變量</li>
</ul>
<p>We will use a list of numbers to demonstrate the concepts and construction of these loop patterns.</p>
<p>我們將使用數字列表來演示這些循環模式的概念和構造。</p>
<p><em><strong>Counting and summing loops 計數和求和循環</strong></em></p>
<p>For example, to count the number of items in a list, we would write the following<span> </span><code>for</code><span> </span>loop:</p>
<p>例如，要計算列表中的項目數，我們將編寫以下for循環：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">count = 0
for itervar in [3, 41, 12, 9, 74, 15]:
    count = count + 1
print('Count: ', count)</pre>
<p>We set the variable<span> </span><code>count</code><span> </span>to zero before the loop starts, then we write a<span> </span><code>for</code><span> </span>loop to run through the list of numbers. Our<span> </span><em>iteration</em><span> </span>variable is named<span> </span><code>itervar</code><span> </span>and while we do not use<span> </span><code>itervar</code><span> </span>in the loop, it does control the loop and cause the loop body to be executed once for each of the values in the list.</p>
<p>我們在循環開始之前將變量count設置為零，然後編寫for循環以遍歷數字列表。我們的迭代變量名為itervar，雖然我們不在循環中使用itervar，但它確實控制了循環並導致循環主體對列表中的每個值執行一次。</p>
<p>In the body of the loop, we add 1 to the current value of<span> </span><code>count</code><span> </span>for each of the values in the list. While the loop is executing, the value of<span> </span><code>count</code><span> </span>is the number of values we have seen "so far".</p>
<p>在循環的主體中，我們為列表中的每個值的當前計數值加1。在執行循環時，count的值就是我們到目前為止所看到的值的數量。</p>
<p>Once the loop completes, the value of<span> </span><code>count</code><span> </span>is the total number of items. The total number "falls in our lap" at the end of the loop. We construct the loop so that we have what we want when the loop finishes.</p>
<p>循環完成後，count的值就是項目的總數。循環結束時總數“落在我們的腿上”。我們構造循環，以便在循環結束時擁有所需的內容。</p>
<p>Another similar loop that computes the total of a set of numbers is as follows:</p>
<p>計算一組數字總數的另一個類似循環如下：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">total = 0
for itervar in [3, 41, 12, 9, 74, 15]:
    total = total + itervar
print('Total: ', total)</pre>
<p>In this loop we<span> </span><em>do</em><span> </span>use the<span> </span><em>iteration variable</em>. Instead of simply adding one to the<span> </span><code>count</code><span> </span>as in the previous loop, we add the actual number (3, 41, 12, etc.) to the running total during each loop iteration. If you think about the variable<span> </span><code>total</code>, it contains the "running total of the values so far". So before the loop starts<span> </span><code>total</code><span> </span>is zero because we have not yet seen any values, during the loop<span> </span><code>total</code><span> </span>is the running total, and at the end of the loop<span> </span><code>total</code><span> </span>is the overall total of all the values in the list.</p>
<p>在此循環中，我們確實使用了迭代變量。我們不像上一個循環那樣簡單地在計數中添加一個數字，而是在每個循環迭代期間將實際數字（3、41、12等）添加到運行總數中。如果考慮變量total，則它包含“到目前為止的值的運行總計”。因此，在循環開始之前，total為零，因為我們尚未看到任何值，在循環期間，total是運行中的總數，而在循環結束時，total是列表中所有值的總和。</p>
<p>As the loop executes,<span> </span><code>total</code><span> </span>accumulates the sum of the elements; a variable used this way is sometimes called an<span> </span><em>accumulator</em>.</p>
<p>循環執行時，total累積元素的總和；這種方式使用的變量有時稱為累加器。</p>
<p>Neither the counting loop nor the summing loop are particularly useful in practice because there are built-in functions<span> </span><code>len()</code><span> </span>and<span> </span><code>sum()</code><span> </span>that compute the number of items in a list and the total of the items in the list respectively.</p>
<p>計數循環和求和循環在實踐中都不是特別有用，因為內置函數len（）和sum（）分別計算列表中的項目數和列表中項目的總數。</p>
<p><em><strong>Maximum and minimum loops 最大和最小循環</strong></em></p>
<p>To find the largest value in a list or sequence, we construct the following loop:</p>
<p>為了找到列表或序列中的最大值，我們構建以下循環：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">largest = None
print('Before:', largest)
for itervar in [3, 41, 12, 9, 74, 15]:
    if largest is None or itervar &gt; largest :
        largest = itervar
    print('Loop:', itervar, largest)
print('Largest:', largest)</pre>
<p>When the program executes, the output is as follows:</p>
<p>程序執行時，輸出如下：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">Before: None
Loop: 3 3
Loop: 41 41
Loop: 12 41
Loop: 9 41
Loop: 74 74
Loop: 15 74
Largest: 74</pre>
<p>The variable<span> </span><code>largest</code><span> </span>is best thought of as the "largest value we have seen so far". Before the loop, we set<span> </span><code>largest</code><span> </span>to the constant<span> </span><code>None</code>.<span> </span><code>None</code><span> </span>is a special constant value which we can store in a variable to mark the variable as "empty".</p>
<p>最好將可變的最大值視為“迄今為止我們看到的最大值”。在循環之前，我們將最大值設置為常數None。 None是一個特殊的常量值，我們可以將其存儲在變量中以將變量標記為“空”。</p>
<p>Before the loop starts, the largest value we have seen so far is<span> </span><code>None</code><span> </span>since we have not yet seen any values. While the loop is executing, if<span> </span><code>largest</code><span> </span>is<span> </span><code>None</code><span> </span>then we take the first value we see as the largest so far. You can see in the first iteration when the value of<span> </span><code>itervar</code><span> </span>is 3, since<span> </span><code>largest</code><span> </span>is<span> </span><code>None</code>, we immediately set<span> </span><code>largest</code><span> </span>to be 3.</p>
<p>在循環開始之前，到目前為止，我們看到的最大值是“無”，因為我們尚未看到任何值。在執行循環時，如果最大值為“無”，那麼我們將採用迄今為止最大的第一個值。您可以在第一次迭代中看到itervar的值為3，因為large是None，我們立即將large設置為3。</p>
<p>After the first iteration,<span> </span><code>largest</code><span> </span>is no longer<span> </span><code>None</code>, so the second part of the compound logical expression that checks<span> </span><code>itervar &gt; largest</code><span> </span>triggers only when we see a value that is larger than the "largest so far". When we see a new "even larger" value we take that new value for<span> </span><code>largest</code>. You can see in the program output that<span> </span><code>largest</code><span> </span>progresses from 3 to 41 to 74.</p>
<p>在第一次迭代之後，最大不再是None，因此僅當我們看到一個大於“到目前為止最大”的值時，用於檢查itervar&gt;最大的複合邏輯表達式的第二部分才觸發。當我們看到一個新的“甚至更大”的值時，我們將這個新值取為最大值。您可以在程序輸出中看到最大進度從3到41到74。</p>
<p>At the end of the loop, we have scanned all of the values and the variable<span> </span><code>largest</code><span> </span>now does contain the largest value in the list.</p>
<p>在循環結束時，我們已經掃描了所有值，並且變量large現在確實包含列表中的最大值。</p>
<p>To compute the smallest number, the code is very similar with one small change:</p>
<p>為了計算最小的數字，代碼非常相似，但有一點點變化：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">smallest = None
print('Before:', smallest)
for itervar in [3, 41, 12, 9, 74, 15]:
    if smallest is None or itervar &lt; smallest:
        smallest = itervar
    print('Loop:', itervar, smallest)
print('Smallest:', smallest)</pre>
<p>Again,<span> </span><code>smallest</code><span> </span>is the "smallest so far" before, during, and after the loop executes. When the loop has completed,<span> </span><code>smallest</code><span> </span>contains the minimum value in the list.</p>
<p>同樣，最小是循環執行之前，期間和之後的“迄今為止最大的”。循環完成後，最小值將包含列表中的最小值。</p>
<p>Again as in counting and summing, the built-in functions<span> </span><code>max()</code><span> </span>and<span> </span><code>min()</code><span> </span>make writing these exact loops unnecessary.</p>
<p>同樣，在計數和求和中，內置函數max（）和min（）使得無需編寫這些確切的循環。</p>
<p>以下是Python內置min（）函數的簡單版本：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def min(values):
    smallest = None
    for value in values:
        if smallest is None or value &lt; smallest:
            smallest = value
    return smallest</pre>
<p>In the function version of the smallest code, we removed all of the<span> </span><code>print</code><span> </span>statements so as to be equivalent to the<span> </span><code>min</code><span> </span>function which is already built in to Python.</p>
<p>在最小代碼的函數版本中，我們刪除了所有print語句，以便等效於Python內置的min函數。</p>
<h3>Debugging 除錯</h3>
<p>As you start writing bigger programs, you might find yourself spending more time debugging. More code means more chances to make an error and more places for bugs to hide.</p>
<p>當您開始編寫更大的程序時，您可能會發現自己花費了更多的時間進行調試。更多的代碼意味著有更多的機會犯錯，並且有更多的地方可以隱藏錯誤。</p>
<p>One way to cut your debugging time is "debugging by bisection." For example, if there are 100 lines in your program and you check them one at a time, it would take 100 steps.</p>
<p>減少調試時間的一種方法是“按部分調試”。例如，如果您的程序中有100行，而您一次只檢查一行，則將需要100步。</p>
<p>Instead, try to break the problem in half. Look at the middle of the program, or near it, for an intermediate value you can check. Add a<span> </span><code>print</code><span> </span>statement (or something else that has a verifiable effect) and run the program.</p>
<p>相反，請嘗試將問題分解成兩半。查看程序的中間或附近，可以檢查中間值。添加打印語句（或其他可驗證的結果）並運行程序。</p>
<p>If the mid-point check is incorrect, the problem must be in the first half of the program. If it is correct, the problem is in the second half.</p>
<p>如果中點檢查不正確，則問題必須出在程序的前半部分。如果正確，則問題出在下半年。</p>
<p>Every time you perform a check like this, you halve the number of lines you have to search. After six steps (which is much less than 100), you would be down to one or two lines of code, at least in theory.</p>
<p>每次執行這樣的檢查時，都將要搜索的行數減半。經過六個步驟（遠遠少於100個步驟），至少從理論上講，您將只有一兩行代碼。</p>
<p>In practice it is not always clear what the "middle of the program" is and not always possible to check it. It doesn't make sense to count lines and find the exact midpoint. Instead, think about places in the program where there might be errors and places where it is easy to put a check. Then choose a spot where you think the chances are about the same that the bug is before or after the check.</p>
<p>在實踐中，並不總是清楚“程序的中間”是什麼，也不總是可以檢查它。計算行數和找到確切的中點沒有意義。相反，請考慮程序中可能存在錯誤的位置以及易於檢查的位置。然後選擇一個您認為錯誤發生在檢查之前或之後的機會相同的位置。</p>
<h3>Glossary 詞彙表</h3>
<dl>
<dt>accumulator</dt>
<dd>A variable used in a loop to add up or accumulate a result.</dd>
<dd><span>循環中用於累加或累加結果的變量。</span></dd>
</dl>
<dl>
<dt>counter</dt>
<dd>A variable used in a loop to count the number of times something happened. We initialize a counter to zero and then increment the counter each time we want to "count" something.</dd>
<dd>循環中使用的變量，用於計算發生某事的次數。我們將計數器初始化為零，然後在每次我們要“計數”某事物時遞增該計數器。</dd>
</dl>
<dl>
<dt>decrement</dt>
<dd>An update that decreases the value of a variable.</dd>
<dd>減少變量值的更新。</dd>
</dl>
<dl>
<dt>initialize</dt>
<dd>
<p>An assignment that gives an initial value to a variable that will be updated.</p>
<p>一種賦值給要更新的變量的初始值。</p>
</dd>
<dt>increment</dt>
<dd>An update that increases the value of a variable (often by one).</dd>
<dd>一個增加變量值（通常為1）的更新。</dd>
</dl>
<dl>
<dt>infinite loop</dt>
<dd>A loop in which the terminating condition is never satisfied or for which there is no terminating condition.</dd>
<dd>永不滿足終止條件或不滿足終止條件的循環。</dd>
</dl>
<dl>
<dt>iteration</dt>
<dd>Repeated execution of a set of statements using either a function that calls itself or a loop.</dd>
<dd>使用調用自身或循環的函數重複執行一組語句。</dd>
</dl>
<h3>Exercises 練習題</h3>
<p>Exercise 1: Write a program which repeatedly reads numbers until the user enters "done". Once "done" is entered, print out the total, count, and average of the numbers. If the user enters anything other than a number, detect their mistake using<span> </span><code>try</code><span> </span>and<span> </span><code>except</code><span> </span>and print an error message and skip to the next number.</p>
<p>練習1：編寫一個程序，該程序反复讀取數字，直到用戶輸入“完成”為止。輸入“完成”後，打印出總數，計數和平均值。如果用戶輸入的不是數字，則使用try和except檢測到他們的錯誤，並打印錯誤消息並跳至下一個數字。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">Enter a number: 4
Enter a number: 5
Enter a number: bad data
Invalid input
Enter a number: 7
Enter a number: done
16 3 5.333333333333333</pre>
<p>Exercise 2: Write another program that prompts for a list of numbers as above and at the end prints out both the maximum and minimum of the numbers instead of the average.</p>
<p>練習2：編寫另一個程序，提示輸入上述數字，最後打印出最大和最小數字，而不是平均值。</p>
<h2>Lists A list is a sequence 每個列表只是個數列</h2>
<p>Like a string, a<span> </span><em>list</em><span> </span>is a sequence of values. In a string, the values are characters; in a list, they can be any type. The values in list are called<span> </span><em>elements</em><span> </span>or sometimes<span> </span><em>items</em>.</p>
<p>像字符串一樣，列表是一系列值。在字符串中，值是字符。在列表中，它們可以是任何類型。列表中的值稱為元素或有時稱為項目。</p>
<p>There are several ways to create a new list; the simplest is to enclose the elements in square brackets (<code>[</code><span> </span>and<span> </span><code>]</code>):</p>
<p>有幾種創建新列表的方法。最簡單的方法是將元素括在方括號（[and]）中：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']</pre>
<p>The first example is a list of four integers. The second is a list of three strings. The elements of a list don't have to be the same type. The following list contains a string, a float, an integer, and (lo!) another list:</p>
<p>第一個示例是四個整數的列表。第二個是三個字符串的列表。列表的元素不必是同一類型。以下列表包含一個字符串，一個浮點數，一個整數和另一個列表：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">['spam', 2.0, 5, [10, 20]]</pre>
<p>A list within another list is<span> </span><em>nested</em>.</p>
<p>另一個列表中的列表是嵌套的。</p>
<p>A list that contains no elements is called an empty list; you can create one with empty brackets,<span> </span><code>[]</code>.</p>
<p>不包含任何元素的列表稱為空列表。您可以使用方括號[]創建一個。</p>
<p>As you might expect, you can assign list values to variables:</p>
<p>如您所料，您可以將列表值分配給變量：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; numbers = [17, 123]
&gt;&gt;&gt; empty = []
&gt;&gt;&gt; print(cheeses, numbers, empty)
['Cheddar', 'Edam', 'Gouda'] [17, 123] []</pre>
<h3>Lists are mutable 列表也可是變數</h3>
<p>The syntax for accessing the elements of a list is the same as for accessing the characters of a string: the bracket operator. The expression inside the brackets specifies the index. Remember that the indices start at 0:</p>
<p>訪問列表元素的語法與訪問字符串字符的語法相同：方括號運算符。方括號內的表達式指定索引。請記住，索引從0開始：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(cheeses[0])</pre>
<p>Unlike strings, lists are mutable because you can change the order of items in a list or reassign an item in a list. When the bracket operator appears on the left side of an assignment, it identifies the element of the list that will be assigned.</p>
<p>與字符串不同，列表是可變的，因為您可以更改列表中項目的順序或重新分配列表中的項目。當方括號運算符出現在分配的左側時，它標識將要分配的列表元素。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; numbers = [17, 123]
&gt;&gt;&gt; numbers[1] = 5
&gt;&gt;&gt; print(numbers)
[17, 5]</pre>
<p>The one-eth element of<span> </span><code>numbers</code>, which used to be 123, is now 5.</p>
<p>以前是123的數字的一個十進制元素現在是5。</p>
<p>You can think of a list as a relationship between indices and elements. This relationship is called a<span> </span><em>mapping</em>; each index "maps to" one of the elements.</p>
<p>您可以將列表視為索引和元素之間的關係。這種關係稱為映射。每個索引“映射到”元素之一。</p>
<p>List indices work the same way as string indices:</p>
<p>列表索引與字符串索引的工作方式相同：</p>
<ul>
<li>
<p>Any integer expression can be used as an index.</p>
任何整數表達式都可以用作索引。</li>
<li>
<p>If you try to read or write an element that does not exist, you get an<span> </span><code>IndexError</code>.</p>
如果嘗試讀取或寫入不存在的元素，則會得到IndexError。</li>
</ul>
<ul>
<li>If an index has a negative value, it counts backward from the end of the list.</li>
</ul>
<p>          如果索引的值為負，則從列表末尾開始倒數。</p>
<p>The<span> </span><code>in</code><span> </span>operator also works on lists.</p>
<p>in運算符也適用於列表。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; 'Edam' in cheeses
True
&gt;&gt;&gt; 'Brie' in cheeses
False</pre>
<h3>Traversing a list 遍歷列表</h3>
<p>The most common way to traverse the elements of a list is with a<span> </span><code>for</code><span> </span>loop. The syntax is the same as for strings:</p>
<p>遍歷列表元素的最常見方法是使用for循環。語法與字符串相同：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">for cheese in cheeses:
    print(cheese)</pre>
<p>This works well if you only need to read the elements of the list. But if you want to write or update the elements, you need the indices. A common way to do that is to combine the functions<span> </span><code>range</code><span> </span>and<span> </span><code>len</code>:</p>
<p>如果您只需要閱讀列表中的元素，則此方法效果很好。但是，如果要編寫或更新元素，則需要索引。常用的方法是結合使用range和len函數：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2</pre>
<p>This loop traverses the list and updates each element.<span> </span><code>len</code><span> </span>returns the number of elements in the list.<span> </span><code>range</code><span> </span>returns a list of indices from 0 to<span> </span><span class="math"><em>n</em> − 1</span>, where<span> </span><span class="math"><em>n</em></span><span> </span>is the length of the list. Each time through the loop,<span> </span><code>i</code><span> </span>gets the index of the next element. The assignment statement in the body uses<span> </span><code>i</code><span> </span>to read the old value of the element and to assign the new value.</p>
<p>該循環遍歷列表並更新每個元素。 len返回列表中的元素數。 range返回一個從0到n-1的索引列表，其中n是列表的長度。每次通過循環，我都會獲取下一個元素的索引。主體中的賦值語句使用i讀取元素的舊值並分配新值。</p>
<p>A<span> </span><code>for</code><span> </span>loop over an empty list never executes the body:</p>
<p>空列表上的for循環永遠不會執行主體：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">for x in empty:
    print('This never happens.')</pre>
<p>Although a list can contain another list, the nested list still counts as a single element. The length of this list is four:</p>
<p>儘管一個列表可以包含另一個列表，但是嵌套列表仍然算作單個元素。此列表的長度為四：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>
<h3>List operations 數列操作</h3>
<p>The<span> </span><code>+</code><span> </span>operator concatenates lists:</p>
<p>+運算符連接列表：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; print(c)
[1, 2, 3, 4, 5, 6]</pre>
<p>Similarly, the operator repeats a list a given number of times:</p>
<p>類似地，運算符將列表重複給定的次數：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; [0] * 4
&gt;&gt;&gt; [1, 2, 3] * 3
[0, 0, 0, 0]
[1, 2, 3, 1, 2, 3, 1, 2, 3]</pre>
<p>The first example repeats four times. The second example repeats the list three times.</p>
<p>第一個示例重複四次。第二個示例將列表重複三次。</p>
<h3>List slices 列表片段</h3>
<p>The slice operator also works on lists:</p>
<p>slice運算符還適用於列表：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3]
['b', 'c']
&gt;&gt;&gt; t[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; t[3:]
['d', 'e', 'f']</pre>
<p>If you omit the first index, the slice starts at the beginning. If you omit the second, the slice goes to the end. So if you omit both, the slice is a copy of the whole list.</p>
<p>如果省略第一個索引，則切片將從開頭開始。如果省略第二個，則切片將結束。因此，如果您同時省略這兩個部分，則該切片將是整個列表的副本。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t[:]
['a', 'b', 'c', 'd', 'e', 'f']</pre>
<p>Since lists are mutable, it is often useful to make a copy before performing operations that fold, spindle, or mutilate lists.</p>
<p>由於列表是可變的，因此在執行折疊，旋轉或破壞列表的操作之前進行複制通常很有用。</p>
<p>A slice operator on the left side of an assignment can update multiple elements:</p>
<p>分配左側的slice運算符可以更新多個元素：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3] = ['x', 'y']
&gt;&gt;&gt; print(t)
['a', 'x', 'y', 'd', 'e', 'f']</pre>
<h3>List methods 列表指令</h3>
<p>Python provides methods that operate on lists. For example,<span> </span><code>append</code><span> </span>adds a new element to the end of a list:</p>
<p>Python提供了對列表進行操作的方法。例如，append將一個新元素添加到列表的末尾：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.append('d')
&gt;&gt;&gt; print(t)
['a', 'b', 'c', 'd']</pre>
<p><code>extend</code><span> </span>takes a list as an argument and appends all of the elements:</p>
<p>擴展將列表作為參數並附加所有元素：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t1 = ['a', 'b', 'c']
&gt;&gt;&gt; t2 = ['d', 'e']
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; print(t1)
['a', 'b', 'c', 'd', 'e']</pre>
<p>This example leaves<span> </span><code>t2</code><span> </span>unmodified.</p>
<p>此示例使t2保持不變。</p>
<p><code>sort</code><span> </span>arranges the elements of the list from low to high:</p>
<p>sort將列表的元素從低到高排列：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; print(t)
['a', 'b', 'c', 'd', 'e']</pre>
<p>Most list methods are void; they modify the list and return<span> </span><code>None</code>. If you accidentally write<span> </span><code>t = t.sort()</code>, you will be disappointed with the result.</p>
<p>大多數列表方法都是無效的。他們修改列表並返回None。如果您不小心寫了t = t.sort（），那麼您會對結果感到失望。</p>
<h3>Deleting elements 刪除元素</h3>
<p>There are several ways to delete elements from a list. If you know the index of the element you want, you can use<span> </span><code>pop</code>:</p>
<p>有幾種從列表中刪除元素的方法。如果知道所需元素的索引，則可以使用pop：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; print(t)
['a', 'c']
&gt;&gt;&gt; print(x)</pre>
<p><code>pop</code><span> </span>modifies the list and returns the element that was removed. If you don't provide an index, it deletes and returns the last element.</p>
<p>pop修改列表並返回已刪除的元素。如果不提供索引，它將刪除並返回最後一個元素。</p>
<p>If you don't need the removed value, you can use the<span> </span><code>del</code><span> </span>operator:</p>
<p>如果不需要刪除的值，則可以使用del運算符：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; print(t)
['a', 'c']</pre>
<p>If you know the element you want to remove (but not the index), you can use<span> </span><code>remove</code>:</p>
<p>如果知道要刪除的元素（但不知道索引），則可以使用remove：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.remove('b')
&gt;&gt;&gt; print(t)
['a', 'c']</pre>
<p>The return value from<span> </span><code>remove</code><span> </span>is<span> </span><code>None</code>.</p>
<p>remove的返回值為None。</p>
<p>To remove more than one element, you can use<span> </span><code>del</code><span> </span>with a slice index:</p>
<p>要刪除多個元素，可以將del與切片索引一起使用：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; print(t)
['a', 'f']
</pre>
<p>As usual, the slice selects all the elements up to, but not including, the second index.</p>
<p>像往常一樣，切片選擇直到（但不包括）第二索引的所有元素。</p>
<h3>Lists and functions 清單和功能</h3>
<p>There are a number of built-in functions that can be used on lists that allow you to quickly look through a list without writing your own loops:</p>
<p>列表中可以使用許多內置函數，這些函數使您可以快速瀏覽列表而無需編寫自己的循環：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; nums = [3, 41, 12, 9, 74, 15]
&gt;&gt;&gt; print(len(nums))
6
&gt;&gt;&gt; print(max(nums))
74
&gt;&gt;&gt; print(min(nums))
3
&gt;&gt;&gt; print(sum(nums))
154
&gt;&gt;&gt; print(sum(nums)/len(nums))
25.666666666666668</pre>
<p>The<span> </span><code>sum()</code><span> </span>function only works when the list elements are numbers. The other functions (<code>max()</code>,<span> </span><code>len()</code>, etc.) work with lists of strings and other types that can be comparable.</p>
<p>sum（）函數僅在列表元素為數字時才有效。其他函數（max（），len（）等）可用於字符串列表和其他可比較的類型。</p>
<p>We could rewrite an earlier program that computed the average of a list of numbers entered by the user using a list.</p>
<p>我們可以重寫一個較早的程序，該程序計算用戶使用列表輸入的數字列表的平均值。</p>
<p>First, the program to compute an average without a list:</p>
<p>首先，該程序無需列表即可計算平均值：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">total = 0
count = 0
while (True):
    inp = input('Enter a number: ')
    if inp == 'done': break
    value = float(inp)
    total = total + value
    count = count + 1

average = total / count
print('Average:', average)</pre>
<p>In this program, we have<span> </span><code>count</code><span> </span>and<span> </span><code>total</code><span> </span>variables to keep the number and running total of the user's numbers as we repeatedly prompt the user for a number.</p>
<p>在此程序中，當我們反复提示用戶輸入數字時，我們保留了count和total變量來保持數字和用戶數字的總和。</p>
<p>We could simply remember each number as the user entered it and use built-in functions to compute the sum and count at the end.</p>
<p>當用戶輸入數字時，我們可以簡單地記住每個數字，並使用內置函數計算最後的總和和計數。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">numlist = list()
while (True):
    inp = input('Enter a number: ')
    if inp == 'done': break
    value = float(inp)
    numlist.append(value)

average = sum(numlist) / len(numlist)
print('Average:', average)</pre>
<p>We make an empty list before the loop starts, and then each time we have a number, we append it to the list. At the end of the program, we simply compute the sum of the numbers in the list and divide it by the count of the numbers in the list to come up with the average.</p>
<p>我們在循環開始前創建一個空列表，然後每次有一個數字時，都會將其附加到列表中。在程序結束時，我們只需計算列表中數字的總和，然後將其除以列表中數字的計數即可得出平均值。</p>
<h3>Lists and strings 列表和字符串</h3>
<p>A string is a sequence of characters and a list is a sequence of values, but a list of characters is not the same as a string. To convert from a string to a list of characters, you can use<span> </span><code>list</code>:</p>
<p>字符串是字符序列，列表是值序列，但是字符列表與字符串不同。要將字符串轉換為字符列表，可以使用list：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; s = 'spam'
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; print(t)
['s', 'p', 'a', 'm']</pre>
<p>Because<span> </span><code>list</code><span> </span>is the name of a built-in function, you should avoid using it as a variable name. I also avoid the letter<span> </span><code>l</code><span> </span>because it looks too much like the number<span> </span><code>1</code>. So that's why I use<span> </span><code>t</code>.</p>
<p>由於list是內置函數的名稱，因此應避免將其用作變量名。我也避免使用字母l，因為它看起來太像數字1。這就是為什麼我使用t的原因。</p>
<p>The<span> </span><code>list</code><span> </span>function breaks a string into individual letters. If you want to break a string into words, you can use the<span> </span><code>split</code><span> </span>method:</p>
<p>列表功能將字符串分成單個字母。如果要將字符串分解為單詞，可以使用split方法：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; s = 'pining for the fjords'
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; print(t)
['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; print(t[2])
the</pre>
<p>Once you have used<span> </span><code>split</code><span> </span>to break the string into a list of words, you can use the index operator (square bracket) to look at a particular word in the list.</p>
<p>一旦使用split將字符串分成單詞列表，就可以使用索引運算符（方括號）查看列表中的特定單詞。</p>
<p>You can call<span> </span><code>split</code><span> </span>with an optional argument called a<span> </span><em>delimiter</em><span> </span>that specifies which characters to use as word boundaries. The following example uses a hyphen as a delimiter:</p>
<p>您可以使用稱為定界符的可選參數調用split，該定界符指定將哪些字符用作單詞邊界。下面的示例使用連字符作為分隔符：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; s = 'spam-spam-spam'
&gt;&gt;&gt; delimiter = '-'
&gt;&gt;&gt; s.split(delimiter)
['spam', 'spam', 'spam']</pre>
<p><code>join</code><span> </span>is the inverse of<span> </span><code>split</code>. It takes a list of strings and concatenates the elements.<span> </span><code>join</code><span> </span>is a string method, so you have to invoke it on the delimiter and pass the list as a parameter:</p>
<p>join是split的逆函數。它接受字符串列表並連接元素。 join是一個字符串方法，因此您必須在定界符上調用它，並將列表作為參數傳遞：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; t = ['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; delimiter = ' '
&gt;&gt;&gt; delimiter.join(t)
'pining for the fjords'</pre>
<p>In this case the delimiter is a space character, so<span> </span><code>join</code><span> </span>puts a space between words. To concatenate strings without spaces, you can use the empty string, "", as a delimiter.</p>
<p>在這種情況下，定界符是空格字符，因此join在單詞之間放置一個空格。要連接沒有空格的字符串，可以使用空字符串“”作為定界符。</p>
<h3>Parsing lines 解析行</h3>
<p>Usually when we are reading a file we want to do something to the lines other than just printing the whole line. Often we want to find the "interesting lines" and then<span> </span><em>parse</em><span> </span>the line to find some interesting<span> </span><em>part</em><span> </span>of the line. What if we wanted to print out the day of the week from those lines that start with "From "?</p>
<p>通常，當我們讀取文件時，除了對整個行進行打印外，我們還希望對行進行一些處理。通常，我們希望找到“有趣的行”，然後解析該行以找到該行中一些有趣的部分。如果我們想從以“發件人”開頭的行中打印出星期幾該怎麼辦？</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">From stephen.marquard@uct.ac.zaSatJan 5 09:14:16 2008

</pre>
<p>The<span> </span><code>split</code><span> </span>method is very effective when faced with this kind of problem. We can write a small program that looks for lines where the line starts with "From ",<span> </span><code>split</code><span> </span>those lines, and then print out the third word in the line:</p>
<p>面對這種問題，拆分方法非常有效。我們可以編寫一個小程序來查找以“ From”開頭的行，拆分這些行，然後打印出該行中的第三個單詞：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if not line.startswith('From '): continue
    words = line.split()
    print(words[2])</pre>
<p></p>
<p>Here we also use the contracted form of the<span> </span><code>if</code><span> </span>statement where we put the<span> </span><code>continue</code><span> </span>on the same line as the<span> </span><code>if</code>. This contracted form of the<span> </span><code>if</code><span> </span>functions the same as if the<span> </span><code>continue</code><span> </span>were on the next line and indented.</p>
<p>在這裡，我們還使用if語句的協定形式，在其中將continue和if放在同一行。 if的這種收縮形式與繼續在下一行並縮進的功能相同。</p>
<p>The program produces the following output:</p>
<p>該程序產生以下輸出：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">Sat
Fri
Fri
Fri
    ...</pre>
<p>Later, we will learn increasingly sophisticated techniques for picking the lines to work on and how we pull those lines apart to find the exact bit of information we are looking for.</p>
<p>稍後，我們將學習越來越複雜的技術，以選擇要使用的線路以及如何將這些線路分開以找到所需的確切信息。</p>
<h3>Objects and values 對象和價值</h3>
<p>If we execute these assignment statements:</p>
<p>如果執行以下賦值語句：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">a = 'banana'
b = 'banana'</pre>
<p>we know that<span> </span><code>a</code><span> </span>and<span> </span><code>b</code><span> </span>both refer to a string, but we don't know whether they refer to the<span> </span><em>same</em><span> </span>string. There are two possible states:</p>
<p>我們知道a和b都引用一個字符串，但是我們不知道它們是否引用同一個字符串。有兩種可能的狀態：</p>
<p><img alt="Variables and Objects" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIxNyAxMiAzMTQgNTciIHdpZHRoPSIzMTRwdCIgaGVpZ2h0PSI1N3B0IiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxtZXRhZGF0YT4gUHJvZHVjZWQgYnkgT21uaUdyYWZmbGUgNi40LjEgPGRjOmRhdGU+MjAxNi0wMS0xNiAxOTowNjo1OSArMDAwMDwvZGM6ZGF0ZT48L21ldGFkYXRhPjxkZWZzPjxmb250LWZhY2UgZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBwYW5vc2UtMT0iMiAwIDUgMyAwIDAgMCAyIDAgNCIgdW5pdHMtcGVyLWVtPSIxMDAwIiB1bmRlcmxpbmUtcG9zaXRpb249Ii0xMDAiIHVuZGVybGluZS10aGlja25lc3M9IjUwIiBzbG9wZT0iMCIgeC1oZWlnaHQ9IjUxNyIgY2FwLWhlaWdodD0iNzE0IiBhc2NlbnQ9Ijk1MS45OTU4NSIgZGVzY2VudD0iLTIxMi45OTc0NCIgZm9udC13ZWlnaHQ9IjUwMCI+PGZvbnQtZmFjZS1zcmM+PGZvbnQtZmFjZS1uYW1lIG5hbWU9IkhlbHZldGljYU5ldWUiLz48L2ZvbnQtZmFjZS1zcmM+PC9mb250LWZhY2U+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIiBtYXJrZXJVbml0cz0ic3Ryb2tlV2lkdGgiIGlkPSJGaWxsZWRBcnJvd19NYXJrZXIiIHZpZXdCb3g9Ii0xIC0zIDcgNiIgbWFya2VyV2lkdGg9IjciIG1hcmtlckhlaWdodD0iNiIgY29sb3I9ImJsYWNrIj48Zz48cGF0aCBkPSJNIDQuOCAwIEwgMCAtMS44IEwgMCAxLjggWiIgZmlsbD0iY3VycmVudENvbG9yIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9nPjwvbWFya2VyPjwvZGVmcz48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1vcGFjaXR5PSIxIiBzdHJva2UtZGFzaGFycmF5PSJub25lIiBmaWxsPSJub25lIiBmaWxsLW9wYWNpdHk9IjEiPjx0aXRsZT5DYW52YXMgMTwvdGl0bGU+PHJlY3QgZmlsbD0id2hpdGUiIHdpZHRoPSI0MDQiIGhlaWdodD0iMjk2Ii8+PGc+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyLjU2MjUgMTgpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iLjIwNCIgeT0iMTUiIHRleHRMZW5ndGg9IjguNTkyIj5hPC90c3Bhbj48L3RleHQ+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjIuMDYyNSA0NSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iNTAwIiB4PSIuMjU2IiB5PSIxNSIgdGV4dExlbmd0aD0iOS40ODgiPmI8L3RzcGFuPjwvdGV4dD48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3Ny4wNjI1IDE4KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9Ii4wMjQiIHk9IjE1IiB0ZXh0TGVuZ3RoPSI2MS45NTIiPuKAmGJhbmFuYeKAmTwvdHNwYW4+PC90ZXh0Pjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDc3LjA2MjUgNDUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iLjAyNCIgeT0iMTUiIHRleHRMZW5ndGg9IjYxLjk1MiI+4oCYYmFuYW5h4oCZPC90c3Bhbj48L3RleHQ+PHBhdGggZD0iTSAzNi41NjI1IDI3IEwgNDIuOTYyNSAyNyBMIDU5LjE2MjUgMjciIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48cGF0aCBkPSJNIDM3LjA2MjUgNTQgTCA0Mi45NjI1IDU0IEwgNTkuMTYyNSA1NCIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMi41NjI1IDE4KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9Ii4yMDQiIHk9IjE1IiB0ZXh0TGVuZ3RoPSI4LjU5MiI+YTwvdHNwYW4+PC90ZXh0Pjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMi4wNjI1IDQ1KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9Ii4yNTYiIHk9IjE1IiB0ZXh0TGVuZ3RoPSI5LjQ4OCI+YjwvdHNwYW4+PC90ZXh0Pjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2My4wNjI1IDMyKSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9Ii4wMjQiIHk9IjE1IiB0ZXh0TGVuZ3RoPSI2MS45NTIiPuKAmGJhbmFuYeKAmTwvdHNwYW4+PC90ZXh0PjxsaW5lIHgxPSIyMTYuNTYyNSIgeTE9IjI4LjUyODczNiIgeDI9IjI0NS4zMjYzNSIgeTI9IjMzLjE1NzQiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMjE3LjA2MjUiIHkxPSI1Mi41MDU3NDciIHgyPSIyNDUuMzA0MTUiIHkyPSI0OC4yODU3MyIgbWFya2VyLWVuZD0idXJsKCNGaWxsZWRBcnJvd19NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIvPjwvZz48L2c+PC9zdmc+Cg=="/></p>
<p>In one case,<span> </span><code>a</code><span> </span>and<span> </span><code>b</code><span> </span>refer to two different objects that have the same value. In the second case, they refer to the same object.</p>
<p>在一種情況下，a和b指的是具有相同值的兩個不同對象。在第二種情況下，它們引用相同的對象。</p>
<p>To check whether two variables refer to the same object, you can use the<span> </span><code>is</code><span> </span>operator.</p>
<p>要檢查兩個變量是否引用同一對象，可以使用is運算符。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; a = 'banana'</pre>
<p>In this example, Python only created one string object, and both<span> </span><code>a</code><span> </span>and<span> </span><code>b</code><span> </span>refer to it.</p>
<p>在此示例中，Python僅創建了一個字符串對象，並且a和b都引用該對象。</p>
<p>But when you create two lists, you get two objects:</p>
<p>但是，當您創建兩個列表時，會得到兩個對象：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False</pre>
<p>In this case we would say that the two lists are<span> </span><em>equivalent</em>, because they have the same elements, but not<span> </span><em>identical</em>, because they are not the same object. If two objects are identical, they are also equivalent, but if they are equivalent, they are not necessarily identical.</p>
<p>在這種情況下，我們可以說這兩個列表是等效的，因為它們具有相同的元素，但是不相同，因為它們不是相同的對象。如果兩個對象相同，則它們也是等效的，但是如果它們相等，則它們不一定相同。</p>
<p>Until now, we have been using "object" and "value" interchangeably, but it is more precise to say that an object has a value. If you execute<span> </span><code>a = [1,2,3]</code>,<span> </span><code>a</code><span> </span>refers to a list object whose value is a particular sequence of elements. If another list has the same elements, we would say it has the same value.</p>
<p>到目前為止，我們一直在交替使用“對象”和“值”，但是更確切地說，對象具有值。如果執行a = [1,2,3]，則a引用列表對象，其值是特定的元素序列。如果另一個列表具有相同的元素，則可以說它具有相同的值。</p>
<h3>Aliasing 混疊</h3>
<p>If<span> </span><code>a</code><span> </span>refers to an object and you assign<span> </span><code>b = a</code>, then both variables refer to the same object:</p>
<p>如果a引用一個對象並且您分配b = a，則兩個變量都引用同一個對象：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True</pre>
<p>The association of a variable with an object is called a<span> </span><em>reference</em>. In this example, there are two references to the same object.</p>
<p>變量與對象的關聯稱為引用。在此示例中，有兩個對同一對象的引用。</p>
<p>An object with more than one reference has more than one name, so we say that the object is<span> </span><em>aliased</em>.</p>
<p>一個具有多個引用的對象具有多個名稱，因此我們說該對像是別名。</p>
<p>If the aliased object is mutable, changes made with one alias affect the other:</p>
<p>如果別名對像是可變的，則使用一個別名進行的更改會影響另一個別名：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; b[0] = 17
&gt;&gt;&gt; print(a)
[17, 2, 3]</pre>
<h2>Files Persistence 檔案開啟</h2>
<p>So far, we have learned how to write programs and communicate our intentions to the<span> </span><em>Central Processing Unit</em><span> </span>using conditional execution, functions, and iterations. We have learned how to create and use data structures in the<span> </span><em>Main Memory</em>. The CPU and memory are where our software works and runs. It is where all of the "thinking" happens.</p>
<p>到目前為止，我們已經學習瞭如何使用條件執行，函數和迭代來編寫程序並將意圖傳達給中央處理器。 我們已經學習瞭如何在主存儲器中創建和使用數據結構。 CPU和內存是我們軟件運行和運行的地方。 這是所有“思考”發生的地方。</p>
<p>But if you recall from our hardware architecture discussions, once the power is turned off, anything stored in either the CPU or main memory is erased. So up to now, our programs have just been transient fun exercises to learn Python.</p>
<p>但是，如果您從我們的硬件架構討論中回想起，一旦電源關閉，存儲在CPU或主存儲器中的所有內容都會被擦除。 因此，到目前為止，我們的程序只是學習Python的短暫有趣練習。</p>
<p><img alt="Secondary Memory" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIxNiAxNiA0NDUgMjY1IiB3aWR0aD0iNDQ1cHQiIGhlaWdodD0iMjY1cHQiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+PG1ldGFkYXRhPiBQcm9kdWNlZCBieSBPbW5pR3JhZmZsZSA2LjQuMSA8ZGM6ZGF0ZT4yMDE2LTAxLTE2IDE4OjQ1OjI2ICswMDAwPC9kYzpkYXRlPjwvbWV0YWRhdGE+PGRlZnM+PGZpbHRlciBpZD0iU2hhZG93IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiPjxmZUdhdXNzaWFuQmx1ciBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0iYmx1ciIgc3RkRGV2aWF0aW9uPSIxLjMwOCIvPjxmZU9mZnNldCBpbj0iYmx1ciIgcmVzdWx0PSJvZmZzZXQiIGR4PSIwIiBkeT0iMiIvPjxmZUZsb29kIGZsb29kLWNvbG9yPSJibGFjayIgZmxvb2Qtb3BhY2l0eT0iLjUiIHJlc3VsdD0iZmxvb2QiLz48ZmVDb21wb3NpdGUgaW49ImZsb29kIiBpbjI9Im9mZnNldCIgb3BlcmF0b3I9ImluIi8+PC9maWx0ZXI+PGZvbnQtZmFjZSBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIHBhbm9zZS0xPSIyIDAgNSAzIDAgMCAwIDIgMCA0IiB1bml0cy1wZXItZW09IjEwMDAiIHVuZGVybGluZS1wb3NpdGlvbj0iLTEwMCIgdW5kZXJsaW5lLXRoaWNrbmVzcz0iNTAiIHNsb3BlPSIwIiB4LWhlaWdodD0iNTE3IiBjYXAtaGVpZ2h0PSI3MTQiIGFzY2VudD0iOTUxLjk5NTg1IiBkZXNjZW50PSItMjEyLjk5NzQ0IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iSGVsdmV0aWNhTmV1ZSIvPjwvZm9udC1mYWNlLXNyYz48L2ZvbnQtZmFjZT48Zm9udC1mYWNlIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTYiIHVuaXRzLXBlci1lbT0iMTAwMCIgdW5kZXJsaW5lLXBvc2l0aW9uPSItNzUuNjgzNTk0IiB1bmRlcmxpbmUtdGhpY2tuZXNzPSI0OS4zMTY0MDYiIHNsb3BlPSIwIiB4LWhlaWdodD0iNTIyLjk0OTIyIiBjYXAtaGVpZ2h0PSI3MTcuMjg1MTYiIGFzY2VudD0iNzcwLjAxOTUzIiBkZXNjZW50PSItMjI5Ljk4MDQ3IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iSGVsdmV0aWNhIi8+PC9mb250LWZhY2Utc3JjPjwvZm9udC1mYWNlPjwvZGVmcz48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1vcGFjaXR5PSIxIiBzdHJva2UtZGFzaGFycmF5PSJub25lIiBmaWxsPSJub25lIiBmaWxsLW9wYWNpdHk9IjEiPjx0aXRsZT5DYW52YXMgMTwvdGl0bGU+PHJlY3QgZmlsbD0id2hpdGUiIHdpZHRoPSI2NTAiIGhlaWdodD0iNzU2Ii8+PGc+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxnPjx4bDp1c2UgeGw6aHJlZj0iI2lkNDVfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48eGw6dXNlIHhsOmhyZWY9IiNpZDQ2X0dyYXBoaWMiIGZpbHRlcj0idXJsKCNTaGFkb3cpIi8+PHhsOnVzZSB4bDpocmVmPSIjaWQ1MF9HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx4bDp1c2UgeGw6aHJlZj0iI2lkNDhfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48eGw6dXNlIHhsOmhyZWY9IiNpZDEwX0dyYXBoaWMiIGZpbHRlcj0idXJsKCNTaGFkb3cpIi8+PC9nPjxyZWN0IHg9IjE4IiB5PSI4MSIgd2lkdGg9IjEwOCIgaGVpZ2h0PSI3MiIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSIxOCIgeT0iODEiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjMgOTApIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTUuMDU2IiB5PSIxNSIgdGV4dExlbmd0aD0iNjcuODg4Ij5JbnB1dCBhbmQ8L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjI0LjI0IiB5PSIzMyIgdGV4dExlbmd0aD0iNDkuNTIiPk91dHB1dDwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMjAuNzA0IiB5PSI1MSIgdGV4dExlbmd0aD0iNTYuNTkyIj5EZXZpY2VzPC90c3Bhbj48L3RleHQ+PHJlY3QgeD0iMTUzIiB5PSI0NSIgd2lkdGg9IjE0NCIgaGVpZ2h0PSIyMzQiIGZpbGw9IndoaXRlIi8+PHJlY3QgeD0iMTUzIiB5PSI0NSIgd2lkdGg9IjE0NCIgaGVpZ2h0PSIyMzQiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU4IDUwKSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjAiIHk9IjE1IiB0ZXh0TGVuZ3RoPSI1NS4zNzYiPlNvZnR3YXI8L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjU1LjA4OCIgeT0iMTUiIHRleHRMZW5ndGg9IjguNTkyIj5lPC90c3Bhbj48L3RleHQ+PHJlY3QgeD0iMTcxIiB5PSIxODkiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIGZpbGw9IndoaXRlIi8+PHJlY3QgeD0iMTcxIiB5PSIxODkiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc2IDIwNykiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iNTAwIiB4PSIzMS41MTIiIHk9IjE1IiB0ZXh0TGVuZ3RoPSIzOS40MjQiPk1haW4gPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iNTAwIiB4PSIxOS42NTYiIHk9IjMzIiB0ZXh0TGVuZ3RoPSI1OC42ODgiPk1lbW9yeTwvdHNwYW4+PC90ZXh0PjxyZWN0IHg9IjE3MSIgeT0iODEiIHdpZHRoPSIxMDgiIGhlaWdodD0iNzIiIGZpbGw9IndoaXRlIi8+PHJlY3QgeD0iMTcxIiB5PSI4MSIgd2lkdGg9IjEwOCIgaGVpZ2h0PSI3MiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzYgOTApIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMjMuMjI0IiB5PSIxNSIgdGV4dExlbmd0aD0iNTEuNTUyIj5DZW50cmFsPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iNTAwIiB4PSI5LjI5NiIgeT0iMzMiIHRleHRMZW5ndGg9IjE1LjY5NiI+UHI8L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjI0LjcwNCIgeT0iMzMiIHRleHRMZW5ndGg9IjY0Ij5vY2Vzc2luZzwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMzQuNDgiIHk9IjUxIiB0ZXh0TGVuZ3RoPSIyOS4wNCI+VW5pdDwvdHNwYW4+PC90ZXh0PjxwYXRoIGQ9Ik0gMzcyIDQ3LjI1IEMgMzcyIDMxLjA3ODA4IDM0NS4xNjQ0IDE4IDMxMiAxOCBDIDI3OC44MzU2IDE4IDI1MiAzMS4wNzgwOCAyNTIgNDcuMjUgQyAyNTIgNjEuMDMxNTIgMjcxLjY4NzIgNzIuNjMyODggMjk4LjExMzYgNzUuNjU2MTYgQyAyOTUuOTQ1MiA4MC44NTk2IDI5Mi4zNzE2IDg2Ljk3NjcyIDI4Ni43NDYgOTAgQyAyOTcuNTg1NiA5MCAzMDguMzA4OCA4Mi44MjgwOCAzMTUuNjMyNCA3Ni40Mjk0NCBDIDM0Ny4wOTc2IDc1LjUxNTc2IDM3MiA2Mi43ODkwNCAzNzIgNDcuMjUgWiIgZmlsbD0id2hpdGUiLz48cGF0aCBkPSJNIDM3MiA0Ny4yNSBDIDM3MiAzMS4wNzgwOCAzNDUuMTY0NCAxOCAzMTIgMTggQyAyNzguODM1NiAxOCAyNTIgMzEuMDc4MDggMjUyIDQ3LjI1IEMgMjUyIDYxLjAzMTUyIDI3MS42ODcyIDcyLjYzMjg4IDI5OC4xMTM2IDc1LjY1NjE2IEMgMjk1Ljk0NTIgODAuODU5NiAyOTIuMzcxNiA4Ni45NzY3MiAyODYuNzQ2IDkwIEMgMjk3LjU4NTYgOTAgMzA4LjMwODggODIuODI4MDggMzE1LjYzMjQgNzYuNDI5NDQgQyAzNDcuMDk3NiA3NS41MTU3NiAzNzIgNjIuNzg5MDQgMzcyIDQ3LjI1IFoiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjc1IDI3KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjE4LjMyOCIgeT0iMTUiIHRleHRMZW5ndGg9IjM3LjM0NCI+V2hhdDwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMTUuODE2IiB5PSIzMyIgdGV4dExlbmd0aD0iNDIuMzY4Ij5OZXh0PzwvdHNwYW4+PC90ZXh0PjxwYXRoIGQ9Ik0gMzQ2LjgxNzczIDExOC41MTE2NCBDIDMyNS45Njg3NSAxMTQgMzM0LjI4MjggNzYuMDE5NCAzNjcuNTQxNTggODIuNSBDIDM3MC42MjcyNiA2OS44NjcyNCA0MDkuMzAyNzUgNzEuOTE3NjggNDA5LjA0OTkgODIuNSBDIDQzMy4zMDA2MiA2OC45NjUwOCA0NjQuMjkxNTggOTUuOTUzNDQgNDQzLjUwNDUyIDEwOS40ODgzNiBDIDQ2OC40NDc5NiAxMTYuMDUwNDQgNDQzLjE4OTc2IDE1MS40MDYwNCA0MjIuNzE4NzUgMTQ1LjUgQyA0MjEuMDgwNDUgMTU1LjM0Mzk2IDM4NC40ODQ0NCAxNTguNzg4OCAzODEuMjcyMzQgMTQ1LjUgQyAzNjAuNTQ5NzggMTU5LjY5MTggMzE3LjMzOTk0IDEzNy44NzExMiAzNDYuODE3NzMgMTE4LjUxMTY0IFoiIGZpbGw9IndoaXRlIi8+PHBhdGggZD0iTSAzNDYuODE3NzMgMTE4LjUxMTY0IEMgMzI1Ljk2ODc1IDExNCAzMzQuMjgyOCA3Ni4wMTk0IDM2Ny41NDE1OCA4Mi41IEMgMzcwLjYyNzI2IDY5Ljg2NzI0IDQwOS4zMDI3NSA3MS45MTc2OCA0MDkuMDQ5OSA4Mi41IEMgNDMzLjMwMDYyIDY4Ljk2NTA4IDQ2NC4yOTE1OCA5NS45NTM0NCA0NDMuNTA0NTIgMTA5LjQ4ODM2IEMgNDY4LjQ0Nzk2IDExNi4wNTA0NCA0NDMuMTg5NzYgMTUxLjQwNjA0IDQyMi43MTg3NSAxNDUuNSBDIDQyMS4wODA0NSAxNTUuMzQzOTYgMzg0LjQ4NDQ0IDE1OC43ODg4IDM4MS4yNzIzNCAxNDUuNSBDIDM2MC41NDk3OCAxNTkuNjkxOCAzMTcuMzM5OTQgMTM3Ljg3MTEyIDM0Ni44MTc3MyAxMTguNTExNjQgWiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNTQuMzUgMTA1KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjEwLjA4NiIgeT0iMTUiIHRleHRMZW5ndGg9IjYwLjEyOCI+TmV0d29yazwvdHNwYW4+PC90ZXh0PjxnIGlkPSJpZDQ1X0dyYXBoaWMiPjxsaW5lIHgxPSIxMjYiIHkxPSIxMTciIHgyPSIxNzAuNSIgeTI9IjExNyIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjMiLz48L2c+PGcgaWQ9ImlkNDZfR3JhcGhpYyI+PGxpbmUgeDE9IjIyNC43NDY1MyIgeTE9IjE4OC41MDAwMSIgeDI9IjIyNC41IiB5Mj0iMTUzIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMyIvPjwvZz48ZyBpZD0iaWQ1MF9HcmFwaGljIj48bGluZSB4MT0iMzQyIiB5MT0iMjI1IiB4Mj0iMjc5LjUiIHkyPSIyMjUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIzIi8+PC9nPjxnIGlkPSJpZDQ4X0dyYXBoaWMiPjxsaW5lIHgxPSIzMzkuMzI2OTQiIHkxPSIxMTQuOTMxMTQ2IiB4Mj0iMjc5LjQ5OTkiIHkyPSIxMTUuOTQwODQiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIzIi8+PC9nPjxnIGlkPSJpZDEwX0dyYXBoaWMiPjxwYXRoIGQ9Ik0gMzQyIDI1My44IEwgMzQyIDE5Ni4yIEMgMzQyIDE5Mi4yMjU2IDM2OC4yMDggMTg5IDQwMC41IDE4OSBDIDQzMi43OTIgMTg5IDQ1OSAxOTIuMjI1NiA0NTkgMTk2LjIgTCA0NTkgMjUzLjggQyA0NTkgMjU3Ljc3NDQgNDMyLjc5MiAyNjEgNDAwLjUgMjYxIEMgMzY4LjIwOCAyNjEgMzQyIDI1Ny43NzQ0IDM0MiAyNTMuOCIgZmlsbD0id2hpdGUiLz48cGF0aCBkPSJNIDM0MiAyNTMuOCBMIDM0MiAxOTYuMiBDIDM0MiAxOTIuMjI1NiAzNjguMjA4IDE4OSA0MDAuNSAxODkgQyA0MzIuNzkyIDE4OSA0NTkgMTkyLjIyNTYgNDU5IDE5Ni4yIEwgNDU5IDI1My44IEMgNDU5IDI1Ny43NzQ0IDQzMi43OTIgMjYxIDQwMC41IDI2MSBDIDM2OC4yMDggMjYxIDM0MiAyNTcuNzc0NCAzNDIgMjUzLjggTSAzNDIgMTk2LjIgQyAzNDIgMjAwLjE3NDQgMzY4LjIwOCAyMDMuNCA0MDAuNSAyMDMuNCBDIDQzMi43OTIgMjAzLjQgNDU5IDIwMC4xNzQ0IDQ1OSAxOTYuMiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNDcgMjA5LjYpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjE1LjI1MzkwNiIgeT0iMTUiIHRleHRMZW5ndGg9Ijc2LjQ5MjE4OCI+U2Vjb25kYXJ5PC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMjQuNjA5Mzc1IiB5PSIzNCIgdGV4dExlbmd0aD0iNTcuNzgxMjUiPk1lbW9yeTwvdHNwYW4+PC90ZXh0PjwvZz48L2c+PC9nPjwvc3ZnPgo="/></p>
<p>In this chapter, we start to work with<span> </span><em>Secondary Memory</em><span> </span>(or files). Secondary memory is not erased when the power is turned off. Or in the case of a USB flash drive, the data we write from our programs can be removed from the system and transported to another system.</p>
<p>在本章中，我們開始使用輔助內存（或文件）。 關閉電源時不會刪除輔助存儲器。 或者，對於USB閃存驅動器，我們從程序中寫入的數據可以從系統中刪除並傳輸到另一個系統。</p>
<p>We will primarily focus on reading and writing text files such as those we create in a text editor. Later we will see how to work with database files which are binary files, specifically designed to be read and written through database software.</p>
<p>我們將主要專注於讀寫文本文件，例如我們在文本編輯器中創建的文本文件。 稍後，我們將看到如何使用二進製文件的數據庫文件，這些文件是專門為通過數據庫軟件讀寫而設計的。</p>
<p><strong>Opening files 開啟檔案</strong></p>
<p>When we want to read or write a file (say on your hard drive), we first must<span> </span><em>open</em><span> </span>the file. Opening the file communicates with your operating system, which knows where the data for each file is stored. When you open a file, you are asking the operating system to find the file by name and make sure the file exists. In this example, we open the file<span> </span><code>mbox.txt</code>, which should be stored in the same folder that you are in when you start Python. You can download this file from<span> </span><a href="http://www.py4e.com/code3/mbox.txt">www.py4e.com/code3/mbox.txt</a></p>
<p>當我們想要讀取或寫入文件時（例如在硬盤驅動器上），我們首先必須打開文件。 打開文件將與您的操作系統通信，該操作系統會知道每個文件的數據存儲在何處。 打開文件時，您正在要求操作系統按名稱查找文件並確保文件存在。 在此示例中，我們打開文件mbox.txt，該文件應存儲在啟動Python時所在的文件夾中。 您可以從<a href="http://www.py4e.com/code3/mbox.txt">www.py4e.com/code3/mbox.txt</a>下載此文件</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; fhand = open('mbox.txt')
&gt;&gt;&gt; print(fhand)
&lt;_io.TextIOWrapper name='mbox.txt' mode='r' encoding='cp1252'&gt;</pre>
<p>If the<span> </span><code>open</code><span> </span>is successful, the operating system returns us a<span> </span><em>file handle</em>. The file handle is not the actual data contained in the file, but instead it is a "handle" that we can use to read the data. You are given a handle if the requested file exists and you have the proper permissions to read the file.</p>
<p>如果打開成功，則操作系統將向我們返回文件句柄。 文件句柄不是文件中包含的實際數據，而是它是我們可以用來讀取數據的“句柄”。 如果所請求的文件存在並且您具有讀取該文件的適當權限，則會為您提供一個句柄。</p>
<p><img alt="A File Handle" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIxNiAxNiAzNTUgMTg0IiB3aWR0aD0iMzU1cHQiIGhlaWdodD0iMTg0cHQiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+PG1ldGFkYXRhPiBQcm9kdWNlZCBieSBPbW5pR3JhZmZsZSA2LjQuMSA8ZGM6ZGF0ZT4yMDE2LTAxLTE2IDE4OjU5OjQxICswMDAwPC9kYzpkYXRlPjwvbWV0YWRhdGE+PGRlZnM+PGZpbHRlciBpZD0iU2hhZG93IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiPjxmZUdhdXNzaWFuQmx1ciBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0iYmx1ciIgc3RkRGV2aWF0aW9uPSIxLjMwOCIvPjxmZU9mZnNldCBpbj0iYmx1ciIgcmVzdWx0PSJvZmZzZXQiIGR4PSIwIiBkeT0iMiIvPjxmZUZsb29kIGZsb29kLWNvbG9yPSJibGFjayIgZmxvb2Qtb3BhY2l0eT0iLjUiIHJlc3VsdD0iZmxvb2QiLz48ZmVDb21wb3NpdGUgaW49ImZsb29kIiBpbjI9Im9mZnNldCIgb3BlcmF0b3I9ImluIi8+PC9maWx0ZXI+PGZvbnQtZmFjZSBmb250LWZhbWlseT0iTWVubG8iIGZvbnQtc2l6ZT0iMTIiIHBhbm9zZS0xPSIyIDExIDYgOSAzIDggNCAyIDIgNCIgdW5pdHMtcGVyLWVtPSIxMDAwIiB1bmRlcmxpbmUtcG9zaXRpb249Ii02My40NzY1NjIiIHVuZGVybGluZS10aGlja25lc3M9IjQzLjk0NTMxMiIgc2xvcGU9IjAiIHgtaGVpZ2h0PSI1NDYuODc1IiBjYXAtaGVpZ2h0PSI3MjkuMDAzOSIgYXNjZW50PSI5MjguMjIyNjYiIGRlc2NlbnQ9Ii0yMzUuODM5ODQiIGZvbnQtd2VpZ2h0PSI1MDAiPjxmb250LWZhY2Utc3JjPjxmb250LWZhY2UtbmFtZSBuYW1lPSJNZW5sby1SZWd1bGFyIi8+PC9mb250LWZhY2Utc3JjPjwvZm9udC1mYWNlPjxmb250LWZhY2UgZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBwYW5vc2UtMT0iMiAwIDUgMyAwIDAgMCAyIDAgNCIgdW5pdHMtcGVyLWVtPSIxMDAwIiB1bmRlcmxpbmUtcG9zaXRpb249Ii0xMDAiIHVuZGVybGluZS10aGlja25lc3M9IjUwIiBzbG9wZT0iMCIgeC1oZWlnaHQ9IjUxNyIgY2FwLWhlaWdodD0iNzE0IiBhc2NlbnQ9Ijk1MS45OTU4NSIgZGVzY2VudD0iLTIxMi45OTc0NCIgZm9udC13ZWlnaHQ9IjUwMCI+PGZvbnQtZmFjZS1zcmM+PGZvbnQtZmFjZS1uYW1lIG5hbWU9IkhlbHZldGljYU5ldWUiLz48L2ZvbnQtZmFjZS1zcmM+PC9mb250LWZhY2U+PGZvbnQtZmFjZSBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTQiIHBhbm9zZS0xPSIyIDAgNSAzIDAgMCAwIDIgMCA0IiB1bml0cy1wZXItZW09IjEwMDAiIHVuZGVybGluZS1wb3NpdGlvbj0iLTEwMCIgdW5kZXJsaW5lLXRoaWNrbmVzcz0iNTAiIHNsb3BlPSIwIiB4LWhlaWdodD0iNTE3IiBjYXAtaGVpZ2h0PSI3MTQiIGFzY2VudD0iOTUxLjk5NTg1IiBkZXNjZW50PSItMjEyLjk5NzQ0IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iSGVsdmV0aWNhTmV1ZSIvPjwvZm9udC1mYWNlLXNyYz48L2ZvbnQtZmFjZT48bWFya2VyIG9yaWVudD0iYXV0byIgb3ZlcmZsb3c9InZpc2libGUiIG1hcmtlclVuaXRzPSJzdHJva2VXaWR0aCIgaWQ9IkZpbGxlZEFycm93X01hcmtlciIgdmlld0JveD0iLTEgLTMgNyA2IiBtYXJrZXJXaWR0aD0iNyIgbWFya2VySGVpZ2h0PSI2IiBjb2xvcj0iYmxhY2siPjxnPjxwYXRoIGQ9Ik0gNC44IDAgTCAwIC0xLjggTCAwIDEuOCBaIiBmaWxsPSJjdXJyZW50Q29sb3IiIHN0cm9rZT0iY3VycmVudENvbG9yIiBzdHJva2Utd2lkdGg9IjEiLz48L2c+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIiBtYXJrZXJVbml0cz0ic3Ryb2tlV2lkdGgiIGlkPSJGaWxsZWRBcnJvd19NYXJrZXJfMiIgdmlld0JveD0iLTYgLTMgNyA2IiBtYXJrZXJXaWR0aD0iNyIgbWFya2VySGVpZ2h0PSI2IiBjb2xvcj0iYmxhY2siPjxnPjxwYXRoIGQ9Ik0gLTQuOCAwIEwgMCAxLjggTCAwIC0xLjggWiIgZmlsbD0iY3VycmVudENvbG9yIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9nPjwvbWFya2VyPjwvZGVmcz48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1vcGFjaXR5PSIxIiBzdHJva2UtZGFzaGFycmF5PSJub25lIiBmaWxsPSJub25lIiBmaWxsLW9wYWNpdHk9IjEiPjx0aXRsZT5DYW52YXMgMTwvdGl0bGU+PHJlY3QgZmlsbD0id2hpdGUiIHdpZHRoPSI0ODciIGhlaWdodD0iNTAwIi8+PGc+PHRpdGxlPkxheWVyIDE8L3RpdGxlPjxnPjx4bDp1c2UgeGw6aHJlZj0iI2lkMTBfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48L2c+PGcgaWQ9ImlkMTBfR3JhcGhpYyI+PHBhdGggZD0iTSAyMDcgMTgwIEwgMjA3IDM2IEMgMjA3IDI2LjA2NCAyNDMuMjg4IDE4IDI4OCAxOCBDIDMzMi43MTIgMTggMzY5IDI2LjA2NCAzNjkgMzYgTCAzNjkgMTgwIEMgMzY5IDE4OS45MzYgMzMyLjcxMiAxOTggMjg4IDE5OCBDIDI0My4yODggMTk4IDIwNyAxODkuOTM2IDIwNyAxODAiIGZpbGw9IndoaXRlIi8+PHBhdGggZD0iTSAyMDcgMTgwIEwgMjA3IDM2IEMgMjA3IDI2LjA2NCAyNDMuMjg4IDE4IDI4OCAxOCBDIDMzMi43MTIgMTggMzY5IDI2LjA2NCAzNjkgMzYgTCAzNjkgMTgwIEMgMzY5IDE4OS45MzYgMzMyLjcxMiAxOTggMjg4IDE5OCBDIDI0My4yODggMTk4IDIwNyAxODkuOTM2IDIwNyAxODAgTSAyMDcgMzYgQyAyMDcgNDUuOTM2IDI0My4yODggNTQgMjg4IDU0IEMgMzMyLjcxMiA1NCAzNjkgNDUuOTM2IDM2OSAzNiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMTIgNTQpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJNZW5sbyIgZm9udC1zaXplPSIxMiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMCIgeT0iMjUiIHRleHRMZW5ndGg9IjExNS41OTM3NSI+RnJvbSBzdGVwaGVuLm0uLjwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJNZW5sbyIgZm9udC1zaXplPSIxMiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMCIgeT0iMzkiIHRleHRMZW5ndGg9IjEyMi44MTgzNiI+UmV0dXJuLVBhdGg6ICZsdDtwLi48L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iTWVubG8iIGZvbnQtc2l6ZT0iMTIiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjAiIHk9IjUzIiB0ZXh0TGVuZ3RoPSIxMzcuMjY3NTgiPkRhdGU6IFNhdCwgNSBKYW4gLi48L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iTWVubG8iIGZvbnQtc2l6ZT0iMTIiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjAiIHk9IjY3IiB0ZXh0TGVuZ3RoPSIxMjIuODE4MzYiPlRvOiBzb3VyY2VAY29sbC4uPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9Ik1lbmxvIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNTAwIiB4PSIwIiB5PSI4MSIgdGV4dExlbmd0aD0iMTE1LjU5Mzc1Ij5Gcm9tOiBzdGVwaGVuLi4uPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9Ik1lbmxvIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNTAwIiB4PSIwIiB5PSI5NSIgdGV4dExlbmd0aD0iMTM3LjI2NzU4Ij5TdWJqZWN0OiBbc2FrYWldLi4uPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9Ik1lbmxvIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNTAwIiB4PSIwIiB5PSIxMDkiIHRleHRMZW5ndGg9IjEzMC4wNDI5NyI+RGV0YWlsczogaHR0cDovLi4uPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9Ik1lbmxvIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNTAwIiB4PSIwIiB5PSIxMjMiIHRleHRMZW5ndGg9IjcuMjI0NjA5NCI+4oCmPC90c3Bhbj48L3RleHQ+PC9nPjxyZWN0IHg9IjE4IiB5PSIxOCIgd2lkdGg9IjEzNSIgaGVpZ2h0PSIxODAiIGZpbGw9IndoaXRlIi8+PHJlY3QgeD0iMTgiIHk9IjE4IiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjE4MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMyAxNTcuNSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iNTAwIiBmaWxsPSJibGFjayIgeD0iNDYuNSIgeT0iMTUiIHRleHRMZW5ndGg9IjEwLjM2OCI+WTwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgZmlsbD0iYmxhY2siIHg9IjU1LjA5MiIgeT0iMTUiIHRleHRMZW5ndGg9IjIzLjQwOCI+b3VyPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iNTAwIiBmaWxsPSJibGFjayIgeD0iMzEuODI4IiB5PSIzMyIgdGV4dExlbmd0aD0iMTUuNjk2Ij5QcjwvdHNwYW4+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgZmlsbD0iYmxhY2siIHg9IjQ3LjIzNiIgeT0iMzMiIHRleHRMZW5ndGg9IjQ1LjkzNiI+b2dyYW08L3RzcGFuPjwvdGV4dD48cmVjdCB4PSIxMzUiIHk9IjM2IiB3aWR0aD0iMjciIGhlaWdodD0iMTA4IiBmaWxsPSIjMDBiZmMwIi8+PHJlY3QgeD0iMTM1IiB5PSIzNiIgd2lkdGg9IjI3IiBoZWlnaHQ9IjEwOCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNDAgNDIpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMy40NDYiIHk9IjEzIiB0ZXh0TGVuZ3RoPSIxMC4xMDgiPkg8L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjMuOTY0IiB5PSIyOSIgdGV4dExlbmd0aD0iOS4wNzIiPkE8L3RzcGFuPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjMuNDQ2IiB5PSI0NSIgdGV4dExlbmd0aD0iMTAuMTA4Ij5OPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE0IiBmb250LXdlaWdodD0iNTAwIiB4PSIzLjU3MiIgeT0iNjEiIHRleHRMZW5ndGg9IjkuODU2Ij5EPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE0IiBmb250LXdlaWdodD0iNTAwIiB4PSI0LjYwOCIgeT0iNzciIHRleHRMZW5ndGg9IjcuNzg0Ij5MPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE0IiBmb250LXdlaWdodD0iNTAwIiB4PSI0LjIyMyIgeT0iOTMiIHRleHRMZW5ndGg9IjguNTU0Ij5FPC90c3Bhbj48L3RleHQ+PHBhdGggZD0iTSAxNzQuOSA5MCBMIDE3Ny43NSA5MCBMIDE3Ny43NSA5OSBMIDE3Ny43NSAxMDggTCAxOTEuMSAxMDggTCAxOTQuMSAxMDgiIG1hcmtlci1lbmQ9InVybCgjRmlsbGVkQXJyb3dfTWFya2VyKSIgbWFya2VyLXN0YXJ0PSJ1cmwoI0ZpbGxlZEFycm93X01hcmtlcl8yKSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiLz48cmVjdCB4PSI3MiIgeT0iMzYiIHdpZHRoPSI2MyIgaGVpZ2h0PSIyNyIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSI3MiIgeT0iMzYiIHdpZHRoPSI2MyIgaGVpZ2h0PSIyNyIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NyA0MC41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIGZpbGw9ImJsYWNrIiB4PSI4LjQyIiB5PSIxNSIgdGV4dExlbmd0aD0iMzYuMTYiPm9wZW48L3RzcGFuPjwvdGV4dD48cmVjdCB4PSI3MiIgeT0iNjMiIHdpZHRoPSI2MyIgaGVpZ2h0PSIyNyIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSI3MiIgeT0iNjMiIHdpZHRoPSI2MyIgaGVpZ2h0PSIyNyIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NyA2Ny41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjcuNTQiIHk9IjE1IiB0ZXh0TGVuZ3RoPSIzNy45MiI+Y2xvc2U8L3RzcGFuPjwvdGV4dD48cmVjdCB4PSI3MiIgeT0iOTAiIHdpZHRoPSI2MyIgaGVpZ2h0PSIyNyIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSI3MiIgeT0iOTAiIHdpZHRoPSI2MyIgaGVpZ2h0PSIyNyIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NyA5NC41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iSGVsdmV0aWNhIE5ldWUiIGZvbnQtc2l6ZT0iMTYiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjEwLjY0NCIgeT0iMTUiIHRleHRMZW5ndGg9IjUuMzI4Ij5yPC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkhlbHZldGljYSBOZXVlIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iNTAwIiB4PSIxNS42ODQiIHk9IjE1IiB0ZXh0TGVuZ3RoPSIyNi42NzIiPmVhZDwvdHNwYW4+PC90ZXh0PjxyZWN0IHg9IjcyIiB5PSIxMTciIHdpZHRoPSI2MyIgaGVpZ2h0PSIyNyIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSI3MiIgeT0iMTE3IiB3aWR0aD0iNjMiIGhlaWdodD0iMjciIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzcgMTIxLjUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EgTmV1ZSIgZm9udC1zaXplPSIxNiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iOS4xOCIgeT0iMTUiIHRleHRMZW5ndGg9IjM0LjY0Ij53cml0ZTwvdHNwYW4+PC90ZXh0PjwvZz48L2c+PC9zdmc+Cg=="/></p>
<p>If the file does not exist,<span> </span><code>open</code><span> </span>will fail with a traceback and you will not get a handle to access the contents of the file:</p>
<p>如果文件不存在，則打開將失敗，並產生回溯，並且您將沒有句柄來訪問文件的內容：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; fhand = open('stuff.txt')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
FileNotFoundError: [Errno 2] No such file or directory: 'stuff.txt'</pre>
<p>Later we will use<span> </span><code>try</code><span> </span>and<span> </span><code>except</code><span> </span>to deal more gracefully with the situation where we attempt to open a file that does not exist.</p>
<p>稍後，我們將使用try和except來更優雅地處理嘗試打開不存在的文件的情況。</p>
<p><strong>Text files and lines 文件和行數</strong></p>
<p>A text file can be thought of as a sequence of lines, much like a Python string can be thought of as a sequence of characters. For example, this is a sample of a text file which records mail activity from various individuals in an open source project development team:</p>
<p><strong><span>可以將文本文件視為一系列行，就像將Python字符串視為一系列字符一樣。 例如，這是一個文本文件的示例，該文件記錄了開源項目開發團隊中來自各個人的郵件活動：</span></strong></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008
Return-Path: &lt;postmaster@collab.sakaiproject.org&gt;
Date: Sat, 5 Jan 2008 09:12:18 -0500
To: source@collab.sakaiproject.org
From: stephen.marquard@uct.ac.za
Subject: [sakai] svn commit: r39772 - content/branches/
Details: http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772
...</pre>
<p>The entire file of mail interactions is available from</p>
<p>郵件交互的整個文件可從以下位置獲得</p>
<p><a href="http://www.py4e.com/code3/mbox.txt">www.py4e.com/code3/mbox.txt</a></p>
<p>and a shortened version of the file is available from</p>
<p>並且可以從以下位置獲得該文件的簡化版本</p>
<p><a href="http://www.py4e.com/code3/mbox-short.txt">www.py4e.com/code3/mbox-short.txt</a></p>
<p><span>These files are in a standard format for a file containing multiple mail messages. The lines which start with "From " separate the messages and the lines which start with "From:" are part of the messages. For more information about the mbox format, see </span><a href="https://books.trinket.io/pfe/en.wikipedia.org/wiki/Mbox">en.wikipedia.org/wiki/Mbox</a><span>.</span></p>
<p><span>這些文件是包含多個郵件的文件的標準格式。 以“發件人”開頭的行分隔了消息，以“發件人：”開頭的行是消息的一部分。 有關mbox格式的詳細信息，請參見<a href="https://books.trinket.io/pfe/en.wikipedia.org/wiki/Mbox">en.wikipedia.org/wiki/Mbox</a>。</span></p>
<p>To break the file into lines, there is a special character that represents the "end of the line" called the<span> </span><em>newline</em><span> </span>character.</p>
<p>為了將文件分成幾行，有一個特殊的字符表示“行尾”，稱為換行符。</p>
<p>In Python, we represent the<span> </span><em>newline</em><span> </span>character as a backslash-n in string constants. Even though this looks like two characters, it is actually a single character. When we look at the variable by entering "stuff" in the interpreter, it shows us the<span> </span><code>\n</code><span> </span>in the string, but when we use<span> </span><code>print</code><span> </span>to show the string, we see the string broken into two lines by the newline character.</p>
<p>在Python中，我們將換行符表示為字符串常量中的反斜杠-n。 即使看起來像兩個字符，它實際上是一個字符。 當我們通過在解釋器中輸入“ stuff”來查看變量時，它將在字符串中顯示\ n，但是當我們使用print來顯示該字符串時，我們會看到該字符串被換行符分成兩行。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; stuff = 'Hello\nWorld!'
&gt;&gt;&gt; stuff
'Hello\nWorld!'
&gt;&gt;&gt; print(stuff)
Hello
World!
&gt;&gt;&gt; stuff = 'X\nY'
&gt;&gt;&gt; print(stuff)
X
Y
&gt;&gt;&gt; len(stuff)
3</pre>
<p>You can also see that the length of the string<span> </span><code>X\nY</code><span> </span>is<span> </span><em>three</em><span> </span>characters because the newline character is a single character.</p>
<p>您還可以看到字符串X \ nY的長度為三個字符，因為換行符是單個字符。</p>
<p>So when we look at the lines in a file, we need to<span> </span><em>imagine</em><span> </span>that there is a special invisible character called the newline at the end of each line that marks the end of the line.</p>
<p>因此，當我們查看文件中的行時，我們需要想像在每行的末尾有一個特殊的不可見字符，稱為換行符，用於標記該行的末尾。</p>
<p>So the newline character separates the characters in the file into lines.</p>
<p>因此，換行符將文件中的字符分成幾行。</p>
<p><strong>Reading files 讀取文件</strong></p>
<p>While the<span> </span><em>file handle</em><span> </span>does not contain the data for the file, it is quite easy to construct a<span> </span><code>for</code><span> </span>loop to read through and count each of the lines in a file:</p>
<p>儘管文件句柄不包含該文件的數據，但是構造一個for循環以讀取併計數文件中的每一行是非常容易的：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">fhand = open('mbox-short.txt')
count = 0
for line in fhand:
    count = count + 1
print('Line Count:', count)</pre>
<p>We can use the file handle as the sequence in our<span> </span><code>for</code><span> </span>loop. Our<span> </span><code>for</code><span> </span>loop simply counts the number of lines in the file and prints them out. The rough translation of the<span> </span><code>for</code><span> </span>loop into English is, "for each line in the file represented by the file handle, add one to the<span> </span><code>count</code><span> </span>variable."</p>
<p>我們可以將文件句柄用作for循環中的序列。 我們的for循環僅計算文件中的行數並打印出來。 for循環的粗略翻譯是：“對於由文件句柄表示的文件中的每一行，將一個添加到count變量中。”</p>
<p>The reason that the<span> </span><code>open</code><span> </span>function does not read the entire file is that the file might be quite large with many gigabytes of data. The<span> </span><code>open</code><span> </span>statement takes the same amount of time regardless of the size of the file. The<span> </span><code>for</code><span> </span>loop actually causes the data to be read from the file.</p>
<p>打開功能無法讀取整個文件的原因是該文件可能很大，包含許多千兆字節的數據。 無論文件大小如何，open語句花費的時間都是相同的。 for循環實際上導致從文件中讀取數據。</p>
<p>When the file is read using a<span> </span><code>for</code><span> </span>loop in this manner, Python takes care of splitting the data in the file into separate lines using the newline character. Python reads each line through the newline and includes the newline as the last character in the<span> </span><code>line</code><span> </span>variable for each iteration of the<span> </span><code>for</code><span> </span>loop.</p>
<p>當以此方式使用for循環讀取文件時，Python會使用換行符將文件中的數據拆分為單獨的行。 Python會通過換行符讀取每一行，並在for循環的每次迭代中將換行符作為line變量中的最後一個字符。</p>
<p>Because the<span> </span><code>for</code><span> </span>loop reads the data one line at a time, it can efficiently read and count the lines in very large files without running out of main memory to store the data. The above program can count the lines in any size file using very little memory since each line is read, counted, and then discarded.</p>
<p>因為for循環一次只讀取一行數據，所以它可以有效地讀取和計數非常大的文件中的行，而不會耗盡主內存來存儲數據。 上面的程序可以使用很少的內存來計數任何大小的文件中的行，因為每一行都被讀取，計數然後丟棄。</p>
<p>If you know the file is relatively small compared to the size of your main memory, you can read the whole file into one string using the<span> </span><code>read</code><span> </span>method on the file handle.</p>
<p>如果您知道文件與主內存的大小相比相對較小，則可以使用文件句柄上的read方法將整個文件讀取為一個字符串。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; fhand = open('mbox-short.txt')
&gt;&gt;&gt; inp = fhand.read()
&gt;&gt;&gt; print(len(inp))
94626
&gt;&gt;&gt; print(inp[:20])
From stephen.marquar</pre>
<p>In this example, the entire contents (all 94,626 characters) of the file<span> </span><code>mbox-short.txt</code><span> </span>are read directly into the variable<span> </span><code>inp</code>. We use string slicing to print out the first 20 characters of the string data stored in<span> </span><code>inp</code>.</p>
<p>在此示例中，文件mbox-short.txt的全部內容（全部94,626個字符）直接讀取到變量inp中。 我們使用字符串切片來打印出存儲在inp中的字符串數據的前20個字符。</p>
<p>When the file is read in this manner, all the characters including all of the lines and newline characters are one big string in the variable<span> </span><em>inp</em>. Remember that this form of the<span> </span><code>open</code><span> </span>function should only be used if the file data will fit comfortably in the main memory of your computer.</p>
<p>以這種方式讀取文件時，變量inp中的所有字符（包括所有行和換行符）都是一個大字符串。 請記住，只有當文件數據可以舒適地容納在計算機的主存儲器中時，才應使用這種形式的打開功能。</p>
<p>If the file is too large to fit in main memory, you should write your program to read the file in chunks using a<span> </span><code>for</code><span> </span>or<span> </span><code>while</code><span> </span>loop.</p>
<p>如果文件太大而無法容納在主內存中，則應編寫程序以使用for或while循環逐塊讀取文件。</p>
<p><strong>Searching through a file 搜索文件</strong></p>
<p>When you are searching through data in a file, it is a very common pattern to read through a file, ignoring most of the lines and only processing lines which meet a particular condition. We can combine the pattern for reading a file with string methods to build simple search mechanisms.</p>
<p>當您搜索文件中的數據時，通讀文件是一種非常常見的模式，它會忽略大多數行，而只處理滿足特定條件的行。 我們可以將讀取文件的模式與字符串方法結合起來，以構建簡單的搜索機制。</p>
<p>For example, if we wanted to read a file and only print out lines which started with the prefix "From:", we could use the string method<span> </span><em>startswith</em><span> </span>to select only those lines with the desired prefix:</p>
<p>例如，如果我們要讀取文件並僅打印出以“ From：”為前綴的行，則可以使用字符串方法startswith來選擇具有所需前綴的那些行：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">fhand = open('mbox-short.txt')
count = 0
for line in fhand:
    if line.startswith('From:'):
        print(line)</pre>
<p>When this program runs, we get the following output:</p>
<p>當該程序運行時，我們得到以下輸出：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">From: stephen.marquard@uct.ac.za
From: louis@media.berkeley.edu
From: zqian@umich.edu
From: rjlowe@iupui.edu
From: zqian@umich.edu
From: rjlowe@iupui.edu
From: cwen@iupui.edu
...</pre>
<p>As your file processing programs get more complicated, you may want to structure your search loops using<span> </span><code>continue</code>. The basic idea of the search loop is that you are looking for "interesting" lines and effectively skipping "uninteresting" lines. And then when we find an interesting line, we do something with that line.</p>
<p>隨著文件處理程序變得越來越複雜，您可能需要使用continue構建搜索循環。 搜索循環的基本思想是，您正在尋找“有趣的”行，並有效地跳過“不有趣的”行。 然後，當我們找到一條有趣的線時，便對該線進行操作。</p>
<p>We can structure the loop to follow the pattern of skipping uninteresting lines as follows:</p>
<p>我們可以按照如下所示跳過無趣的行的結構來構造循環：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    # Skip 'uninteresting lines'
    if not line.startswith('From:'):
        continue
    # Process our 'interesting' line
    print(line)</pre>
<p>The output of the program is the same. In English, the uninteresting lines are those which do not start with "From:", which we skip using<span> </span><code>continue</code>. For the "interesting" lines (i.e., those that start with "From:") we perform the processing on those lines.</p>
<p>程序的輸出是相同的。 用英語來說，無趣的行是那些不以“ From：”開頭的行，我們跳過了繼續。 對於“有趣的”行（即以“ From：”開頭的行），我們對這些行進行處理。</p>
<p>We can use the<span> </span><code>find</code><span> </span>string method to simulate a text editor search that finds lines where the search string is anywhere in the line. Since<span> </span><code>find</code><span> </span>looks for an occurrence of a string within another string and either returns the position of the string or -1 if the string was not found, we can write the following loop to show lines which contain the string "<span class="citation">@uct.ac.za</span>" (i.e., they come from the University of Cape Town in South Africa):</p>
<p>我們可以使用find string方法來模擬文本編輯器搜索，該搜索將查找行中任何位置的行。 由於find在另一個字符串中查找某個字符串的出現，並返回該字符串的位置；如果找不到該字符串，則返回-1，我們可以編寫以下循環以顯示包含字符串“ @ uct.ac.za的行” ”（即，他們來自南非開普敦大學）：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if line.find('@uct.ac.za') == -1: continue
    print(line)</pre>
<p>Which produces the following output:</p>
<p>產生以下輸出：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
X-Authentication-Warning: set sender to stephen.marquard@uct.ac.za using -f
From: stephen.marquard@uct.ac.za
Author: stephen.marquard@uct.ac.za
From david.horwitz@uct.ac.za Fri Jan  4 07:02:32 2008
X-Authentication-Warning: set sender to david.horwitz@uct.ac.za using -f
From: david.horwitz@uct.ac.za
Author: david.horwitz@uct.ac.za
...</pre>
<p><strong>Letting the user choose the file name 讓用戶選擇文件名</strong></p>
<p>We really do not want to have to edit our Python code every time we want to process a different file. It would be more usable to ask the user to enter the file name string each time the program runs so they can use our program on different files without changing the Python code.</p>
<p>我們真的不想每次想要處理不同文件時都必須編輯Python代碼。 要求用戶在每次程序運行時輸入文件名字符串，這樣他們就可以在不更改Python代碼的情況下在不同文件上使用我們的程序，這將更有用。</p>
<p>This is quite simple to do by reading the file name from the user using<span> </span><code>input</code><span> </span>as follows:</p>
<p>通過使用如下所示的輸入從用戶讀取文件名來完成此操作非常簡單：</p>
<p>We read the file name from the user and place it in a variable named<span> </span><code>fname</code><span> </span>and open that file. Now we can run the program repeatedly on different files.</p>
<p>我們從用戶那裡讀取文件名，並將其放在名為fname的變量中，然後打開該文件。 現在，我們可以在不同文件上重複運行該程序。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python search6.py
Enter the file name: mbox.txt
There were 1797 subject lines in mbox.txt

python search6.py
Enter the file name: mbox-short.txt
There were 27 subject lines in mbox-short.txt</pre>
<p>Before peeking at the next section, take a look at the above program and ask yourself, "What could go possibly wrong here?" or "What might our friendly user do that would cause our nice little program to ungracefully exit with a traceback, making us look not-so-cool in the eyes of our users?"</p>
<p>在瀏覽下一部分之前，請看一下上面的程序並問自己：“這裡可能出什麼問題了？” 還是“友好的用戶可能會做些什麼，而這會導致我們的漂亮小程序因回溯而不合時宜地退出，從而使我們在用戶眼中顯得不太酷？”</p>
<p><strong>Using try, except, and open 使用try，except和open</strong></p>
<p>I told you not to peek. This is your last chance.</p>
<p>我告訴過你不要偷看。 這是您最後的機會。</p>
<p>What if our user types something that is not a file name?</p>
<p>如果我們的用戶鍵入的不是文件名怎麼辦？</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">python search6.py
Enter the file name: missing.txt
Traceback (most recent call last):
  File "search6.py", line 2, in &lt;module&gt;
    fhand = open(fname)
FileNotFoundError: [Errno 2] No such file or directory: 'missing.txt'

python search6.py
Enter the file name: na na boo boo
Traceback (most recent call last):
  File "search6.py", line 2, in &lt;module&gt;
    fhand = open(fname)
FileNotFoundError: [Errno 2] No such file or directory: 'na na boo boo'</pre>
<p>Do not laugh. Users will eventually do every possible thing they can do to break your programs, either on purpose or with malicious intent. As a matter of fact, an important part of any software development team is a person or group called<span> </span><em>Quality Assurance</em><span> </span>(or QA for short) whose very job it is to do the craziest things possible in an attempt to break the software that the programmer has created.</p>
<p>不要笑。 用戶最終將有意或有惡意地盡一切可能破壞您的程序。 實際上，任何軟件開發團隊的重要組成部分都是一個稱為“質量保證”（簡稱QA）的人員或團隊，其職責是盡最大可能地嘗試破壞程序員擁有的軟件。 創建。</p>
<p>The QA team is responsible for finding the flaws in programs before we have delivered the program to the end users who may be purchasing the software or paying our salary to write the software. So the QA team is the programmer's best friend.</p>
<p>質量保證團隊負責在我們將程序交付給可能正在購買軟件或支付我們的薪水以編寫軟件的最終用戶之前發現程序中的缺陷。 因此，質量檢查團隊是程序員的最好朋友。</p>
<p>So now that we see the flaw in the program, we can elegantly fix it using the<span> </span><code>try</code>/<code>except</code><span> </span>structure. We need to assume that the<span> </span><code>open</code><span> </span>call might fail and add recovery code when the<span> </span><code>open</code><span> </span>fails as follows:</p>
<p>因此，既然我們看到了程序中的缺陷，就可以使用try / except結構優雅地修復它。 我們需要假設打開調用可能失敗，並在打開失敗時添加恢復代碼，如下所示：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">fname = input('Enter the file name: ')
try:
    fhand = open(fname)
except:
    print('File cannot be opened:', fname)
    exit()
count = 0
for line in fhand:
    if line.startswith('Subject:'):
        count = count + 1
print('There were', count, 'subject lines in', fname)</pre>
<p>The<span> </span><code>exit</code><span> </span>function terminates the program. It is a function that we call that never returns. Now when our user (or QA team) types in silliness or bad file names, we "catch" them and recover gracefully:</p>
<p>退出功能終止程序。 我們稱之為永不返回的函數。 現在，當我們的用戶（或質量檢查小組）輸入無聊或錯誤的文件名時，我們“捕獲”它們並正常恢復：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">python search7.py
Enter the file name: mbox.txt
There were 1797 subject lines in mbox.txt

python search7.py
Enter the file name: na na boo boo
File cannot be opened: na na boo boo</pre>
<p>Protecting the<span> </span><code>open</code><span> </span>call is a good example of the proper use of<span> </span><code>try</code><span> </span>and<span> </span><code>except</code><span> </span>in a Python program. We use the term "Pythonic" when we are doing something the "Python way". We might say that the above example is the Pythonic way to open a file.</p>
<p>保護open調用是正確使用try的一個很好的例子，但在Python程序中除外。 當我們以“ Python方式”做某事時，我們使用術語“ Pythonic”。 我們可以說上面的示例是打開文件的Pythonic方法。</p>
<p>Once you become more skilled in Python, you can engage in repartee with other Python programmers to decide which of two equivalent solutions to a problem is "more Pythonic". The goal to be "more Pythonic" captures the notion that programming is part engineering and part art. We are not always interested in just making something work, we also want our solution to be elegant and to be appreciated as elegant by our peers.</p>
<p>一旦您掌握了Python的技能，便可以與其他Python程序員進行交流，以確定問題的兩個等效解決方案中的哪一個是“更Python化的”。 成為“更多Python語言”的目標體現了編程是工程和藝術的觀念。 我們並不總是對使某件事情起作用感興趣，我們還希望我們的解決方案既優雅又能被同行所讚賞。</p>
<p><strong>Writing files 寫文件</strong></p>
<p>To write a file, you have to open it with mode "w" as a second parameter:</p>
<p>要寫入文件，必須使用模式“ w”作為第二個參數打開它：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; fout = open('output.txt', 'w')
&gt;&gt;&gt; print(fout)
&lt;_io.TextIOWrapper name='output.txt' mode='w' encoding='cp1252'&gt;</pre>
<p>If the file already exists, opening it in write mode clears out the old data and starts fresh, so be careful! If the file doesn't exist, a new one is created.</p>
<p>如果該文件已經存在，則以寫入模式打開它會清除舊數據並重新開始，所以請當心！ 如果該文件不存在，則會創建一個新文件。</p>
<p>The<span> </span><code>write</code><span> </span>method of the file handle object puts data into the file, returning the number of characters written. The default write mode is text for writing (and reading) strings.</p>
<p>文件句柄對象的write方法將數據放入文件中，返回寫入的字符數。 默認的寫入模式是用於寫入（和讀取）字符串的文本。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; line1 = "This here's the wattle,\n"
&gt;&gt;&gt; fout.write(line1)
24</pre>
<p>Again, the file object keeps track of where it is, so if you call<span> </span><code>write</code><span> </span>again, it adds the new data to the end.</p>
<p>再次，文件對象跟踪其位置，因此，如果再次調用write，它將把新數據添加到末尾。</p>
<p>We must make sure to manage the ends of lines as we write to the file by explicitly inserting the newline character when we want to end a line. The<span> </span><code>print</code><span> </span>statement automatically appends a newline, but the<span> </span><code>write</code><span> </span>method does not add the newline automatically.</p>
<p>我們要確保在寫入文件時通過在要結束一行時顯式插入換行符來管理行尾。 print語句自動添加換行符，但是write方法不會自動添加換行符。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; line2 = 'the emblem of our land.\n'
&gt;&gt;&gt; fout.write(line2)
24</pre>
<p>When you are done writing, you have to close the file to make sure that the last bit of data is physically written to the disk so it will not be lost if the power goes off.</p>
<p>完成寫入後，必須關閉文件以確保將最後一部分數據物理寫入磁盤，這樣即使斷電也不會丟失數據。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; fout.close()
</pre>
<p>We could close the files which we open for read as well, but we can be a little sloppy if we are only opening a few files since Python makes sure that all open files are closed when the program ends. When we are writing files, we want to explicitly close the files so as to leave nothing to chance.</p>
<p>我們也可以關閉打開以供讀取的文件，但是如果我們只打開幾個文件，則可能有點草率，因為Python會確保在程序結束時關閉所有打開的文件。 編寫文件時，我們希望顯式關閉文件，以免發生任何意外。</p>
<p><strong>Debugging 除錯</strong></p>
<p><strong></strong>When you are reading and writing files, you might run into problems with whitespace. These errors can be hard to debug because spaces, tabs, and newlines are normally invisible:</p>
<p>在讀取和寫入文件時，您可能會遇到空白問題。 這些錯誤很難調試，因為空格，製表符和換行符通常是不可見的：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; s = '1 2\t 3\n 4'
&gt;&gt;&gt; print(s)
1 2  3
 4</pre>
<p>The built-in function<span> </span><code>repr</code><span> </span>can help. It takes any object as an argument and returns a string representation of the object. For strings, it represents whitespace characters with backslash sequences:</p>
<p>內置功能repr可以提供幫助。 它以任何對像作為參數，並返回該對象的字符串表示形式。 對於字符串，它表示帶有反斜杠序列的空格字符：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(repr(s))
'1 2\t 3\n 4'</pre>
<p>This can be helpful for debugging.</p>
<p>這對於調試很有幫助。</p>
<p>One other problem you might run into is that different systems use different characters to indicate the end of a line. Some systems use a newline, represented<span> </span><code>\n</code>. Others use a return character, represented<span> </span><code>\r</code>. Some use both. If you move files between different systems, these inconsistencies might cause problems.</p>
<p>您可能會遇到的另一個問題是，不同的系統使用不同的字符來指示行尾。 某些系統使用換行符，表示為\ n。 其他人則使用返回字符\ r表示。 有些同時使用。 如果在不同系統之間移動文件，則這些不一致可能會引起問題。</p>
<p>For most systems, there are applications to convert from one format to another. You can find them (and read more about this issue) at<span> </span><a href="https://books.trinket.io/pfe/wikipedia.org/wiki/Newline">wikipedia.org/wiki/Newline</a>. Or, of course, you could write one yourself.</p>
<p>對於大多數係統，有些應用程序可以將一種格式轉換為另一種格式。 您可以在<a href="https://books.trinket.io/pfe/wikipedia.org/wiki/Newline">Wikipedia.org/wiki/Newline</a>上找到它們（並了解有關此問題的更多信息）。 或者，當然，您可以自己寫一個。</p>
<p><strong>Glossary 詞彙表</strong></p>
<p>catch</p>
<dl>
<dd>To prevent an exception from terminating a program using the<span> </span><code>try</code><span> </span>and<span> </span><code>except</code><span> </span>statements.</dd>
<dd>為了防止異常使用try和except語句終止程序。</dd>
</dl>
<dl>
<dt>newline</dt>
<dd>A special character used in files and strings to indicate the end of a line.</dd>
<dd>在文件和字符串中使用的特殊字符，用於指示行的結尾。</dd>
</dl>
<dl>
<dt>Pythonic</dt>
<dd>A technique that works elegantly in Python. "Using try and except is the<span> </span><em>Pythonic</em><span> </span>way to recover from missing files".</dd>
<dd>在Python中優雅地工作的技術。 “使用try和except是從丟失的文件中恢復的Python方式”。</dd>
</dl>
<dl>
<dt>Quality Assurance</dt>
<dd>A person or team focused on insuring the overall quality of a software product. QA is often involved in testing a product and identifying problems before the product is released.</dd>
<dd>一個人或一個團隊專注於確保軟件產品的整體質量。 質量檢查通常涉及產品的測試和產品發布之前的發現問題。</dd>
</dl>
<dl>
<dt>text file</dt>
<dd>A sequence of characters stored in permanent storage like a hard drive.</dd>
<dd>存儲在永久存儲區（如硬盤驅動器）中的一系列字符。</dd>
</dl>
<strong>Exercises 練習題</strong></div>
<div class="activitywrap purpose learnbydoing flash"><strong><strong></strong></strong>Exercise 1: Write a program to read through a file and print the contents of the file (line by line) all in upper case. Executing the program will look as follows:
<p>練習1：編寫一個程序以讀取文件並逐行打印文件內容（全部為大寫）。 執行程序如下所示：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python shout.py
Enter a file name: mbox-short.txt
FROM STEPHEN.MARQUARD@UCT.AC.ZA SAT JAN  5 09:14:16 2008
RETURN-PATH: &lt;POSTMASTER@COLLAB.SAKAIPROJECT.ORG&gt;
RECEIVED: FROM MURDER (MAIL.UMICH.EDU [141.211.14.90])
     BY FRANKENSTEIN.MAIL.UMICH.EDU (CYRUS V2.3.8) WITH LMTPA;
     SAT, 05 JAN 2008 09:14:16 -0500</pre>
<p>You can download the file from</p>
<p>您可以從以下位置下載文件</p>
<p><a href="http://www.py4e.com/code3/mbox-short.txt">www.py4e.com/code3/mbox-short.txt</a></p>
<p>Exercise 2: Write a program to prompt for a file name, and then read through the file and look for lines of the form:</p>
<p>練習2：編寫程序以提示輸入文件名，然後通讀文件並查找以下形式的行：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">X-DSPAM-Confidence:0.8475</pre>
<p>When you encounter a line that starts with "X-DSPAM-Confidence:" pull apart the line to extract the floating-point number on the line. Count these lines and then compute the total of the spam confidence values from these lines. When you reach the end of the file, print out the average spam confidence.</p>
<p>當遇到以“ X-DSPAM-Confidence：”開頭的行時，將其拉開以提取該行上的浮點數。 計算這些行，然後從這些行計算垃圾郵件可信度值的總和。 到達文件末尾時，打印出垃圾郵件的平均置信度。</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">Enter the file name: mbox.txt
Average spam confidence: 0.894128046745

Enter the file name: mbox-short.txt
Average spam confidence: 0.750718518519</pre>
<p>Test your file on the<span> </span><code>mbox.txt</code><span> </span>and<span> </span><code>mbox-short.txt</code><span> </span>files.</p>
<p>在mbox.txt和mbox-short.txt文件上測試您的文件。</p>
<p>Exercise 3: Sometimes when programmers get bored or want to have a bit of fun, they add a harmless<span> </span><em>Easter Egg</em><span> </span>to their program Modify the program that prompts the user for the file name so that it prints a funny message when the user types in the exact file name "na na boo boo". The program should behave normally for all other files which exist and don't exist. Here is a sample execution of the program:</p>
<p>練習3：有時，當程序員感到無聊或想找點樂子時，他們在程序中添加了無害的複活節彩蛋。修改程序以提示用戶輸入文件名，以便在用戶鍵入以下內容時打印出有趣的消息： 確切的文件名“ na na boo boo”。 該程序應該對所有其他存在的和不存在的文件正常運行。 這是程序的示例執行：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">ython egg.py
Enter the file name: mbox.txt
There were 1797 subject lines in mbox.txt

python egg.py
Enter the file name: missing.tyxt
File cannot be opened: missing.tyxt

python egg.py
Enter the file name: na na boo boo
NA NA BOO BOO TO YOU - You have been punk'd!</pre>
<h1>HW3</h1>
<h2>PH24</h2>
<p><strong>Draw A Game Board Exercise 24 畫遊戲板練</strong></p>
<p>This exercise is Part 1 of 4 of the Tic Tac Toe exercise series. The other exercises are: Part 2, Part 3, and Part 4.<br/>Time for some fake graphics! Let’s say we want to draw game boards that look like this:<br/>此練習是Tic Tac Toe練習系列4的第1部分。 其他練習是：第2部分，第3部分和第4部分。<br/>是時候購買一些假圖形了！ 假設我們要繪製如下游戲板：<br/> --- --- --- <br/>| | | | <br/> --- --- --- <br/>| | | | <br/> --- --- --- <br/>| | | | <br/> --- --- --- <br/>This one is 3x3 (like in tic tac toe). Obviously, they come in many other sizes (8x8 for chess, 19x19 for Go, and many more).<br/>這是3x3（就像井字遊戲一樣）。 顯然，它們有許多其他尺寸（國際象棋為8x8，圍棋為19x19等）。<br/>Ask the user what size game board they want to draw, and draw it for them to the screen using Python’s print statement.<br/>詢問用戶他們想繪製什麼尺寸的遊戲板，並使用Python的print語句將其繪製到屏幕上。<br/>Remember that in Python 3, printing to the screen is accomplished by<br/>請記住，在Python 3中，打印到屏幕是通過以下方式完成的：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"> print("Thing to show on screen")</pre>
<p>Topics and links for more information 主題和鏈接，以獲取更多信息</p>
<p>The main topic of this exercise is functions. They are tricky, and deserve lots of practice and thought. Here are a few links in case you want some more reading.<br/>本練習的主要主題是功能。 它們很棘手，值得大量實踐和思考。 這裡有一些鏈接，以備您需要更多閱讀。</p>
<p>1.Functions on TutorialsPoint (<a href="http://www.tutorialspoint.com/python/python_functions.htm" title="http://www.tutorialspoint.com/python/python_functions.htm">http://www.tutorialspoint.com/python/python_functions.htm</a>)<br/>2.Hands-on Python, by Loyola University (<a href="http://anh.cs.luc.edu/python/handson/3.1/handsonHtml/functions.html">http://anh.cs.luc.edu/python/handson/3.1/handsonHtml/functions.html</a>)<br/>3.Learn Python the Hard Way (<a href="https://learnpythonthehardway.org/book/ex21.html">https://learnpythonthehardway.org/book/ex21.html</a>)<br/>4.ZetCode (<a href="http://zetcode.com/lang/python/functions/">http://zetcode.com/lang/python/functions/</a>)<br/>There are hundreds more out there - read and practice away!<br/>那裡還有數百個-閱讀它和練習吧！</p>
<h2>PH25</h2>
<p><strong>Guessing Game Two Exercise 25 猜字遊戲二練習25</strong></p>
<p>In a previous exercise, we’ve written a program that “knows” a number and asks a user to guess it.<br/>在上一個練習中，我們編寫了一個程序，該程序“知道”一個數字並要求用戶猜測它。<br/>This time, we’re going to do exactly the opposite. You, the user, will have in your head a number between 0 and 100. The program will guess a number, and you, the user, will say whether it is too high, too low, or your number.<br/>這次，我們將做相反的事情。 您（用戶）的腦海中會有一個介於0到100之間的數字。程序將猜測一個數字，而您（用戶）將說出它是太高，太低還是您的數字。</p>
<p><br/>At the end of this exchange, your program should print out how many guesses it took to get your number.<br/>交換結束後，您的程序應打印出獲得號碼所需的猜測次數。<br/>As the writer of this program, you will have to choose how your program will strategically guess. A naive strategy can be to simply start the guessing at 1, and keep going (2, 3, 4, etc.) until you hit the number. But that’s not an optimal guessing strategy. An alternate strategy might be to guess 50 (right in the middle of the range), and then increase / decrease by 1 as needed. After you’ve written the program, try to find the optimal strategy! (We’ll talk about what is the optimal one next week with the solution.)<br/>作為該程序的作者，您將不得不選擇您的程序將如何進行戰略性猜測。 幼稚的策略可以是簡單地從1開始猜測，然後繼續進行（2、3、4等），直到您得出數字。 但這不是最佳的猜測策略。 另一種策略是猜測50（在範圍的中間），然後根據需要增加/減少1。 編寫完程序後，嘗試找到最佳策略！ （我們將在下週討論該解決方案的最佳選擇。）</p>
<p><br/>Topics and links for more information 主題和鏈接，以獲取更多信息</p>
<p>This exercise doesn’t need any functions, but it does need extensive use of variables, math, and user input.<br/>此練習不需要任何功能，但確實需要大量使用變量，數學和用戶輸入。<br/>You can refer to this exercise on user input, this one on rock paper scissors, and many others.(<a href="https://www.practicepython.org/exercise/2014/01/29/01-character-input.html">https://www.practicepython.org/exercise/2014/01/29/01-character-input.html</a>)(<a href="https://www.practicepython.org/exercise/2014/03/26/08-rock-paper-scissors.html">https://www.practicepython.org/exercise/2014/03/26/08-rock-paper-scissors.html</a>)<br/>您可以在用戶輸入上參考此練習，在石頭剪刀上參考此練習，以及其他許多參考。<br/>If you want to implement the optimal solution without thinking about it first, you can read this Wikipedia article on binary search.(<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">https://en.wikipedia.org/wiki/Binary_search_algorithm</a>)<br/>如果您想在不首先考慮的情況下實施最佳解決方案，則可以閱讀有關二進制搜索的Wikipedia文章。</p>
<h2>PH26</h2>
<p><strong>Check Tic Tac Toe Exercise 26 檢查井字練習26</strong></p>
<p>This exercise is Part 2 of 4 of the Tic Tac Toe exercise series. The other exercises are: Part 1, Part 3, and Part 4.<br/>此練習是Tic Tac Toe練習系列4的第2部分。 其他練習是：第1部分，第3部分和第4部分。<br/>As you may have guessed, we are trying to build up to a full tic-tac-toe board. However, this is significantly more than half an hour of coding, so we’re doing it in pieces.<br/>您可能已經猜到了，我們正在努力建立完整的井字遊戲板。 但是，這遠遠超過了半個小時的編碼，因此我們要分批進行。<br/>Today, we will simply focus on checking whether someone has WON a game of Tic Tac Toe, not worrying about how the moves were made.<br/>今天，我們將只關注檢查某人是否贏得了井字遊戲，而不必擔心這些動作是如何進行的。<br/>If a game of Tic Tac Toe is represented as a list of lists, like so:<br/>如果井字遊戲被表示為列表列表，例如：</p>
<p>game = [[1, 2, 0],<br/> [2, 1, 0],<br/> [2, 1, 1]]</p>
<p>where a 0 means an empty square, a 1 means that player 1 put their token in that space, and a 2 means that player 2 put their token in that space.<br/>其中0表示空白方塊，(1)表示玩家1將令牌放置在該空間中，而(2)表示玩家2將令牌放置在該空間中。<br/>Your task this week: given a 3 by 3 list of lists that represents a Tic Tac Toe game board, tell me whether anyone has won, and tell me which player won, if any. A Tic Tac Toe win is 3 in a row - either in a row, a column, or a diagonal. Don’t worry about the case where TWO people have won - assume that in every board there will only be one winner.<br/>本週的任務：給一個3排3的列表，代表一個Tic Tac Toe遊戲板，告訴我是否有人贏了，告訴我哪個玩家贏了（如果有）。 井字遊戲的勝利是連續3個-連續，一列或對角線。 不必擔心會有兩個人獲勝的情況-假設在每個董事會中只有一個獲勝者。<br/>Here are some more examples to work with:<br/>以下是一些可以使用的示例：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">winner_is_2 = [[2, 2, 0],
	[2, 1, 0],
	[2, 1, 1]]

winner_is_1 = [[1, 2, 0],
	[2, 1, 0],
	[2, 1, 1]]

winner_is_also_1 = [[0, 1, 0],
	[2, 1, 0],
	[2, 1, 1]]

no_winner = [[1, 2, 0],
	[2, 1, 0],
	[2, 1, 2]]

also_no_winner = [[1, 2, 0],
	[2, 1, 0],
	[2, 1, 0]]</pre>
<p>Topics<br/>This exercise is challenging, but doable with only lists (of lists)! Lists of lists are nearly the same as lists, just a bit trickier. Remember that to get the first element in a list called my_list = [5, 10, 15], you index it with a variable like so:</p>
<p>此練習具有挑戰性，但僅可使用列表中的列表！列表的列表與列表幾乎相同，只是比較棘手。請記住，要獲取名為my_list = [5，10，15]的列表中的第一個元素，請使用如下所示的變量對其進行索引：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(my_list[0])
	5
	&gt;&gt;&gt; print(my_list[-1])
	15
	&gt;&gt;&gt; print(len(my_list))
	3</pre>
<p>When working with lists of lists, it is the same! Say you have a list matrix = [[1, 2], [3, 4]]. Then, take a look at this:<br/>使用列表列表時，是一樣的！ 假設您有一個列表矩陣= [[1，2]，[3，4]]。 然後，看看這個：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&gt;&gt;&gt; print(matrix[0])
	[1, 2]
	&gt;&gt;&gt; print(matrix[-1])
	[3, 4]
	&gt;&gt;&gt; first_row = matrix[0]
	&gt;&gt;&gt; print(first_row[0])
	1
	&gt;&gt;&gt; print(matrix[0][0])
	1
	&gt;&gt;&gt; print(matrix[1][1])
	4
</pre>
<p>The cool part is that you can use double-indexing to read the elements from our list of lists matrix! By indexing matrix[0][1] we are saying give me the 1st element of the 0th element of matrix, which in this case is 2.<br/>最酷的部分是您可以使用雙索引從列表列表矩陣中讀取元素！ 通過索引矩陣[0] [1]，我們要給我矩陣第0個元素的第一個元素，在這種情況下為2。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>